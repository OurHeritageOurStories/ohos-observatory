var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
import { isReactive, reactive, provide, inject, watch, toRef, watchEffect, computed, unref, ref, onMounted, onUnmounted, nextTick, defineComponent, openBlock, createElementBlock, useAttrs, Fragment, mergeProps, createCommentVNode, createElementVNode, createTextVNode, toDisplayString, renderList, normalizeClass, withModifiers, renderSlot, createVNode, createBlock, normalizeStyle, TransitionGroup, withCtx, resolveDynamicComponent, readonly, resolveComponent, normalizeProps, guardReactiveProps, createSlots } from "vue";
const LayerPositions = [
  "paths",
  "nodes",
  "focusring",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
function Reactive(value) {
  if (isReactive(value)) {
    return value;
  } else {
    return reactive(value);
  }
}
function nonNull(val, name = "Parameter") {
  if (val === void 0 || val === null) {
    throw new Error(`${name} is null`);
  }
  return val;
}
const containersKey = Symbol("containers");
function provideContainers(containers) {
  provide(containersKey, containers);
}
function useContainers() {
  const containers = nonNull(inject(containersKey), "containers");
  return {
    container: containers.container,
    svg: containers.svg,
    viewport: containers.viewport,
    svgPanZoom: containers.svgPanZoom
  };
}
class Config {
  static value(value, target) {
    return value instanceof Function ? value(target) : value;
  }
  static values(value, target) {
    if (Object.values(value).filter((v) => v instanceof Function).length === 0) {
      return value;
    }
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, v instanceof Function ? v(target) : v]));
  }
}
var NodeLabelDirection = /* @__PURE__ */ ((NodeLabelDirection2) => {
  NodeLabelDirection2["CENTER"] = "center";
  NodeLabelDirection2["NORTH"] = "north";
  NodeLabelDirection2["NORTH_EAST"] = "north-east";
  NodeLabelDirection2["EAST"] = "east";
  NodeLabelDirection2["SOUTH_EAST"] = "south-east";
  NodeLabelDirection2["SOUTH"] = "south";
  NodeLabelDirection2["SOUTH_WEST"] = "south-west";
  NodeLabelDirection2["WEST"] = "west";
  NodeLabelDirection2["NORTH_WEST"] = "north-west";
  return NodeLabelDirection2;
})(NodeLabelDirection || {});
function withSelf(callback) {
  const self2 = {};
  return Object.assign(self2, callback(self2));
}
function configsWithType(configs) {
  return configs;
}
function defineConfigs(configs) {
  return configs;
}
function getNodeSize(node, style, scale) {
  const shape = Config.values(style.normal, node);
  if (shape.type == "circle") {
    return {
      width: shape.radius * 2 * scale,
      height: shape.radius * 2 * scale
    };
  } else {
    return {
      width: shape.width * scale,
      height: shape.height * scale
    };
  }
}
function areNodesCollision(nodePos, nodeSize, targetNodePos, targetNodeSize) {
  const distanceX = Math.abs(nodePos.x - targetNodePos.x);
  const collisionX = distanceX < nodeSize.width / 2 + targetNodeSize.width / 2;
  const distanceY = Math.abs(nodePos.y - targetNodePos.y);
  const collisionY = distanceY < nodeSize.height / 2 + targetNodeSize.height / 2;
  return collisionX && collisionY;
}
function applyScaleToDasharray(dasharray, scale) {
  let result = 0;
  if (scale === 1 || dasharray === void 0 || dasharray === "none") {
    result = dasharray != null ? dasharray : 0;
  } else if (typeof dasharray === "string") {
    result = dasharray.split(/\s+/).map((v) => parseInt(v) * scale).filter((v) => !isNaN(v)).join(" ");
  } else {
    result = dasharray * scale;
  }
  return result && result !== "0" ? result : void 0;
}
function getDasharrayUnit(dasharray) {
  let result = 0;
  if (dasharray === void 0 || dasharray === "none") {
    result = 0;
  } else if (typeof dasharray === "string") {
    const array = dasharray.split(/\s+/).map((v) => parseInt(v)).filter((v) => !isNaN(v));
    if (array.length % 2 === 0) {
      result = array.reduce((s, n) => s + n, 0);
    } else {
      result = array.reduce((s, n) => s + n, 0) * 2;
    }
  } else {
    result = dasharray * 2;
  }
  return result;
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$1 || value === -INFINITY$1) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function arrayMap(array, iteratee) {
  var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index < length2) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var isArray = Array.isArray;
var isArray$1 = isArray;
var INFINITY = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$1(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
var nativeIsFinite = root$1.isFinite, nativeMin = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
    if (precision && nativeIsFinite(number)) {
      var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number);
  };
}
var round = createRound("round");
var round$1 = round;
const NEW_NODE_POSITION_MARGIN = 20;
class SimpleLayout {
  activate(parameters) {
    const { layouts, nodes, configs, emitter, scale, svgPanZoom: svgPanZoom2 } = parameters;
    const onDrag = (positions) => {
      for (const [id, pos] of Object.entries(positions)) {
        const layout = this.getOrCreateNodePosition(layouts, id);
        this.setNodePosition(layout, pos);
      }
    };
    const setNewNodePositions = (nodeIds) => {
      const newNodes = nodeIds.filter((n) => !(n in layouts));
      const area = svgPanZoom2.getViewArea();
      const s = scale.value;
      for (const nodeId of newNodes) {
        const node = nodes.value[nodeId];
        const nodeSize = getNodeSize(node, configs.node, s);
        const candidate = __spreadValues({}, area.center);
        for (; ; ) {
          let collision = false;
          for (const [id, pos] of Object.entries(layouts)) {
            if (nodeId === id)
              continue;
            const targetNode = nodes.value[id];
            if (!targetNode)
              continue;
            const targetNodeSize = getNodeSize(targetNode, configs.node, s);
            collision = areNodesCollision(candidate, nodeSize, pos, targetNodeSize);
            if (collision) {
              break;
            }
          }
          if (collision) {
            candidate.x += nodeSize.width + NEW_NODE_POSITION_MARGIN * s;
            if (candidate.x + nodeSize.width / 2 > area.box.right) {
              candidate.x = area.center.x;
              candidate.y += nodeSize.height + NEW_NODE_POSITION_MARGIN * s;
            }
          } else {
            break;
          }
        }
        const layout = this.getOrCreateNodePosition(layouts, nodeId);
        this.setNodePosition(layout, candidate);
      }
    };
    setNewNodePositions(Object.keys(nodes.value));
    const stopNodeWatch = watch(() => Object.keys(nodes.value), setNewNodePositions);
    emitter.on("node:dragstart", onDrag);
    emitter.on("node:pointermove", onDrag);
    emitter.on("node:dragend", onDrag);
    this.onDeactivate = () => {
      stopNodeWatch();
      emitter.off("node:dragstart", onDrag);
      emitter.off("node:pointermove", onDrag);
      emitter.off("node:dragend", onDrag);
    };
  }
  deactivate() {
    if (this.onDeactivate) {
      this.onDeactivate();
    }
  }
  setNodePosition(nodeLayout, pos) {
    nodeLayout.value.x = round$1(pos.x, 3);
    nodeLayout.value.y = round$1(pos.y, 3);
  }
  getOrCreateNodePosition(layouts, node) {
    const layout = toRef(layouts, node);
    if (!layout.value) {
      layout.value = { x: 0, y: 0 };
    }
    return layout;
  }
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length2) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0, allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
  buffer.copy(result);
  return result;
}
var Uint8Array2 = root$1.Uint8Array;
var Uint8Array$1 = Uint8Array2;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array) {
  var index = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index < length2) {
    array[index] = source[index];
  }
  return array;
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectProto$9 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
  return value === proto;
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length2 = props.length;
  while (++index < length2) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
function identity(value) {
  return value;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$1 = Math.max;
function overRest(func, start, transform) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length2 = nativeMax$1(args.length - start, 0), array = Array(length2);
    while (++index < length2) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + "");
}
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index < length2) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge$1 = merge;
function getConfigDefaults() {
  return {
    view: {
      scalingObjects: false,
      panEnabled: true,
      zoomEnabled: true,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      doubleClickZoomEnabled: true,
      mouseWheelZoomEnabled: true,
      autoPanAndZoomOnLoad: "center-content",
      autoPanOnResize: true,
      layoutHandler: new SimpleLayout(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: false,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      }
    },
    node: withSelf((self2) => ({
      normal: {
        type: "circle",
        radius: 16,
        width: 32,
        height: 32,
        borderRadius: 4,
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (node) => Config.value(self2.normal.type, node),
        radius: (node) => {
          var _a;
          return ((_a = Config.value(self2.normal.radius, node)) != null ? _a : 0) + 2;
        },
        width: (node) => {
          var _a;
          return ((_a = Config.value(self2.normal.width, node)) != null ? _a : 0) + 2;
        },
        height: (node) => {
          var _a;
          return ((_a = Config.value(self2.normal.height, node)) != null ? _a : 0) + 2;
        },
        borderRadius: (node) => {
          var _a;
          return (_a = Config.value(self2.normal.borderRadius, node)) != null ? _a : 0;
        },
        strokeWidth: (node) => Config.value(self2.normal.strokeWidth, node),
        strokeColor: (node) => Config.value(self2.normal.strokeColor, node),
        strokeDasharray: (node) => Config.value(self2.normal.strokeDasharray, node),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: true,
      selectable: false,
      label: {
        visible: true,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        margin: 4,
        direction: NodeLabelDirection.SOUTH,
        text: "name"
      },
      focusring: {
        visible: true,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      zOrder: {
        enabled: false,
        zIndex: 0,
        bringToFrontOnHover: true,
        bringToFrontOnSelected: true
      },
      transition: void 0
    })),
    edge: withSelf((self2) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: false,
        animationSpeed: 50
      },
      hover: {
        width: (edge) => Config.value(self2.normal.width, edge) + 1,
        color: "#3355bb",
        dasharray: (edge) => Config.value(self2.normal.dasharray, edge),
        linecap: (edge) => Config.value(self2.normal.linecap, edge),
        animate: (edge) => Config.value(self2.normal.animate, edge),
        animationSpeed: (edge) => Config.value(self2.normal.animationSpeed, edge)
      },
      selected: {
        width: (edge) => Config.value(self2.normal.width, edge) + 1,
        color: "#dd8800",
        dasharray: (edge) => {
          const w = Config.value(self2.normal.width, edge);
          return `${w * 1.5} ${w * 2}`;
        },
        linecap: (edge) => Config.value(self2.normal.linecap, edge),
        animate: (edge) => Config.value(self2.normal.animate, edge),
        animationSpeed: (edge) => Config.value(self2.normal.animationSpeed, edge)
      },
      selectable: false,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (_edges, configs) => {
        return configs.edge.type == "curve" ? false : null;
      },
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          radius: 6,
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: false,
          animationSpeed: 50
        }
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        margin: 4,
        padding: 4
      },
      zOrder: {
        enabled: false,
        zIndex: 0,
        bringToFrontOnHover: true,
        bringToFrontOnSelected: true
      }
    })),
    path: withSelf((self2) => ({
      visible: false,
      clickable: false,
      hoverable: false,
      curveInNode: false,
      end: "centerOfNode",
      margin: 0,
      path: reactive({
        width: 6,
        color: (p) => {
          const list = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ];
          const hash = p.edges.map((s) => s.split("").reduce((a, b) => {
            a = (a << 5) - a + b.charCodeAt(0);
            return a & a;
          }, 0)).reduce((a, b) => a + b, 0);
          return list[Math.abs(hash) % list.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: false,
        animationSpeed: 50
      }),
      normal: {
        width: (path) => Config.value(self2.path.width, path),
        color: (path) => Config.value(self2.path.color, path),
        dasharray: (path) => Config.value(self2.path.dasharray, path),
        linecap: (path) => Config.value(self2.path.linecap, path),
        linejoin: (path) => Config.value(self2.path.linejoin, path),
        animate: (path) => Config.value(self2.path.animate, path),
        animationSpeed: (path) => Config.value(self2.path.animationSpeed, path)
      },
      hover: {
        width: (path) => Config.value(self2.normal.width, path) + 2,
        color: (path) => Config.value(self2.normal.color, path),
        dasharray: (path) => Config.value(self2.normal.dasharray, path),
        linecap: (path) => Config.value(self2.normal.linecap, path),
        linejoin: (path) => Config.value(self2.normal.linejoin, path),
        animate: (path) => Config.value(self2.normal.animate, path),
        animationSpeed: (path) => Config.value(self2.normal.animationSpeed, path)
      },
      selected: {
        width: (path) => Config.value(self2.normal.width, path) + 2,
        color: (path) => Config.value(self2.normal.color, path),
        dasharray: "6 12",
        linecap: (path) => Config.value(self2.normal.linecap, path),
        linejoin: (path) => Config.value(self2.normal.linejoin, path),
        animate: (path) => Config.value(self2.normal.animate, path),
        animationSpeed: (path) => Config.value(self2.normal.animationSpeed, path)
      },
      selectable: false,
      zOrder: {
        enabled: false,
        zIndex: 0,
        bringToFrontOnHover: true,
        bringToFrontOnSelected: true
      },
      transition: void 0
    }))
  };
}
function getFullConfigs(config) {
  const configs = getConfigDefaults();
  if (config) {
    merge$1(configs, config);
  }
  return configs;
}
const injectionKey = Symbol("style");
function provideConfigs(configs) {
  const results = reactive(getConfigDefaults());
  const styleKeys = Object.keys(results);
  for (const key of styleKeys) {
    watch(() => configs.value[key], () => {
      merge$1(results[key], configs.value[key] || {});
    }, { immediate: true, deep: true });
  }
  provide(injectionKey, results);
  return results;
}
function injectConfig(key) {
  return nonNull(inject(injectionKey), `Configs(${key})`)[key];
}
function useViewConfig() {
  return injectConfig("view");
}
function useNodeConfig() {
  return injectConfig("node");
}
function useEdgeConfig() {
  return injectConfig("edge");
}
function usePathConfig() {
  return injectConfig("path");
}
let nextId = 1;
function useId() {
  return nextId++;
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length2) {
    this.add(values[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length;
  while (++index < length2) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array, values) {
  var index = -1, length2 = values.length, offset = array.length;
  while (++index < length2) {
    array[offset + index] = values[index];
  }
  return array;
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function arrayFilter(array, predicate) {
  var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length2) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var WeakMap = getNative(root$1, "WeakMap");
var WeakMap$1 = WeakMap;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function entriesOf(obj) {
  return Object.entries(obj);
}
function updateObjectDiff(target, from) {
  const keys2 = new Set(Object.keys(target));
  entriesOf(from).forEach(([key, value]) => {
    if (!isEqual(target[key], value)) {
      target[key] = value;
    }
    keys2.delete(key);
  });
  keys2.forEach((k) => delete target[k]);
}
function makeEdgeGroupStates(nodes, edges, configs) {
  const state = Reactive({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  watchEffect(() => {
    const { edgeLayoutPoints, edgeGroups } = calculateEdgeGroupAndPositions(configs, nodes.value, edges.value);
    updateObjectDiff(state.edgeLayoutPoints, edgeLayoutPoints);
    updateObjectDiff(state.edgeGroups, edgeGroups);
  });
  watchEffect(() => {
    const summarizedEdges = {};
    for (const [id, { edges: edges2, groupWidth }] of Object.entries(state.edgeGroups)) {
      let summarize = false;
      if (groupWidth == 0) {
        summarize = false;
      } else if (configs.edge.summarize instanceof Function) {
        const s = configs.edge.summarize(edges2, configs);
        if (s === null) {
          summarize = defaultCheckSummarize(nodes.value, edges2, configs, groupWidth);
        } else {
          summarize = s;
        }
      } else if (configs.edge.summarize) {
        summarize = defaultCheckSummarize(nodes.value, edges2, configs, groupWidth);
      } else {
        summarize = false;
      }
      state.edgeGroups[id].summarize = summarize;
      if (summarize) {
        Object.keys(edges2).forEach((id2) => summarizedEdges[id2] = true);
      }
    }
    updateObjectDiff(state.summarizedEdges, summarizedEdges);
  });
  return state;
}
function calculateEdgeShiftedPosition(p, isSummarized, source, target, scale, keepOrder) {
  if (!p) {
    return { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } };
  }
  if (isSummarized) {
    return calculateEdgePositionInner(p.edge, source, target, scale, 0, 0, keepOrder);
  } else {
    return calculateEdgePositionInner(p.edge, source, target, scale, p.groupWidth, p.pointInGroup, keepOrder);
  }
}
function calculateEdgeGroupAndPositions(configs, nodes, edges) {
  const edgeLayoutPoints = {};
  const edgeGroups = {};
  const map = {};
  for (const [id, edge] of Object.entries(edges)) {
    if (!(edge.source in nodes && edge.target in nodes)) {
      continue;
    }
    const key = [edge.source, edge.target].sort().join("<=>");
    const values = map[key] || {};
    values[id] = edge;
    map[key] = values;
  }
  const calcGap = configs.edge.gap instanceof Function ? configs.edge.gap : (_e, _c) => configs.edge.gap;
  for (const [key, edges2] of Object.entries(map)) {
    const edgeLen = Object.keys(edges2).length;
    if (edgeLen == 0)
      continue;
    const gap = calcGap(edges2, configs);
    const [edgeId, edge] = Object.entries(edges2)[0];
    if (edgeLen === 1) {
      edgeLayoutPoints[edgeId] = { edge, pointInGroup: 0, groupWidth: 0 };
      edgeGroups[key] = { edges: edges2, groupWidth: 0, summarize: false };
    } else {
      let pointInGroup = 0;
      const lineHalfWidths = Object.entries(edges2).map(([id, edge2]) => {
        let width = Config.value(configs.edge.normal.width, edge2);
        if (isNaN(+width)) {
          console.warn("[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]", id, width);
          width = 1;
        }
        return width / 2;
      });
      const points = Object.entries(edges2).map(([edgeId2, edge2], i) => {
        if (i > 0) {
          pointInGroup += lineHalfWidths[i - 1] + gap + lineHalfWidths[i];
        }
        return [edgeId2, edge2, pointInGroup];
      });
      const groupWidth = pointInGroup;
      points.forEach(([edgeId2, edge2, pointInGroup2]) => {
        edgeLayoutPoints[edgeId2] = { edge: edge2, pointInGroup: pointInGroup2, groupWidth };
      });
      edgeGroups[key] = { edges: edges2, groupWidth, summarize: false };
    }
  }
  return { edgeLayoutPoints, edgeGroups };
}
function defaultCheckSummarize(nodes, edges, configs, width) {
  const edgeCount = Object.entries(edges).length;
  if (edgeCount === 1)
    return false;
  const minWidth = Math.min(...Object.values(edges).flatMap((e) => [nodes[e.source], nodes[e.target]]).filter((v) => v).map((node) => {
    const shape = Config.values(configs.node.normal, node);
    if (shape.type === "circle") {
      return shape.radius * 2;
    } else {
      return Math.min(shape.width, shape.height);
    }
  }));
  return width > minWidth;
}
function calculateEdgePositionInner(edge, source, target, scale, groupWidth, pointInGroup, keepOrder) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let x1, y1, x2, y2;
  if (edge.source < edge.target) {
    [x1, y1, x2, y2] = calculateLinePosition((_a = source == null ? void 0 : source.x) != null ? _a : 0, (_b = source == null ? void 0 : source.y) != null ? _b : 0, (_c = target == null ? void 0 : target.x) != null ? _c : 0, (_d = target == null ? void 0 : target.y) != null ? _d : 0, scale, groupWidth, pointInGroup, keepOrder);
  } else {
    [x2, y2, x1, y1] = calculateLinePosition((_e = target == null ? void 0 : target.x) != null ? _e : 0, (_f = target == null ? void 0 : target.y) != null ? _f : 0, (_g = source == null ? void 0 : source.x) != null ? _g : 0, (_h = source == null ? void 0 : source.y) != null ? _h : 0, scale, groupWidth, pointInGroup, keepOrder);
  }
  return { p1: { x: x1, y: y1 }, p2: { x: x2, y: y2 } };
}
function calculateLinePosition(x1, y1, x2, y2, scale, groupWidth, pointInGroup, keepOrder) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  let diff = (groupWidth / 2 - pointInGroup) * scale;
  if (diff !== 0 && keepOrder !== "clock") {
    const radian = Math.atan2(y2 - y1, x2 - x1);
    if (keepOrder === "vertical") {
      const perpendicular = Math.PI / 2;
      if (radian < -perpendicular || radian >= perpendicular) {
        diff *= -1;
      }
    } else if (keepOrder === "horizontal") {
      if (radian < 0) {
        diff *= -1;
      }
    }
  }
  if (dx === 0) {
    const sign = dy < 0 ? -1 : 1;
    return [x1 + diff * sign, y1, x2 + diff * sign, y2];
  } else if (dy === 0) {
    const sign = dx < 0 ? 1 : -1;
    return [x1, y1 + diff * sign, x2, y2 + diff * sign];
  } else {
    const slope = dy / dx;
    const moveSlope = -1 / slope;
    if (dy < 0) {
      diff = -diff;
    }
    const diffX = diff / Math.sqrt(1 + Math.pow(moveSlope, 2));
    return [x1 + diffX, y1 + diffX * moveSlope, x2 + diffX, y2 + diffX * moveSlope];
  }
}
function add(v1, v2, target) {
  if (!target) {
    target = { x: 0, y: 0 };
  }
  target.x = v1.x + v2.x;
  target.y = v1.y + v2.y;
  return target;
}
function subtract(v1, v2, target) {
  if (!target) {
    target = { x: 0, y: 0 };
  }
  target.x = v1.x - v2.x;
  target.y = v1.y - v2.y;
  return target;
}
function multiply(v1, v2, target) {
  if (!target) {
    target = { x: 0, y: 0 };
  }
  target.x = v1.x * v2.x;
  target.y = v1.y * v2.y;
  return target;
}
function multiplyScalar(v, scalar, target) {
  if (!target) {
    target = { x: 0, y: 0 };
  }
  target.x = v.x * scalar;
  target.y = v.y * scalar;
  return target;
}
function divide(v1, v2, target) {
  if (!target) {
    target = { x: 0, y: 0 };
  }
  target.x = v1.x / v2.x;
  target.y = v1.y / v2.y;
  return target;
}
function dot(v1, v2) {
  return v1.x * v2.x + v1.y * v2.y;
}
function cross(v1, v2) {
  return v1.x * v2.y - v1.y * v2.x;
}
function lengthSquared(v) {
  return v.x * v.x + v.y * v.y;
}
function length(v) {
  return Math.sqrt(lengthSquared(v));
}
function distanceSquared(v1, v2) {
  const dx = v1.x - v2.x;
  const dy = v1.y - v2.y;
  return dx * dx + dy * dy;
}
function distance(v1, v2) {
  return Math.sqrt(distanceSquared(v1, v2));
}
function normalize(v, target) {
  if (!target) {
    target = { x: 0, y: 0 };
  }
  const len = length(v);
  if (len === 0) {
    target.x = 1;
    target.y = 0;
  } else {
    divide(v, { x: len, y: len }, target);
  }
  return target;
}
function rotate(v, angle2, target) {
  if (!target) {
    target = { x: 0, y: 0 };
  }
  const newX = v.x * Math.cos(angle2) - v.y * Math.sin(angle2);
  const newY = v.x * Math.sin(angle2) + v.y * Math.cos(angle2);
  target.x = newX;
  target.y = newY;
  return target;
}
const DEGREES = 180 / Math.PI;
function rad2deg(rad) {
  return rad * DEGREES;
}
function angle(v) {
  return Math.atan2(v.y, v.x);
}
function angleDegree(v) {
  return rad2deg(angle(v));
}
var V$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  add,
  subtract,
  multiply,
  multiplyScalar,
  divide,
  dot,
  cross,
  lengthSquared,
  length,
  distanceSquared,
  distance,
  normalize,
  rotate,
  angle,
  angleDegree
});
class Vector2D {
  static fromArray(array) {
    return new Vector2D(array[0] || 0, array[1] || 0);
  }
  static fromObject(obj) {
    return new Vector2D(obj.x, obj.y);
  }
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  add(v) {
    return add(this, v, this);
  }
  subtract(v) {
    return subtract(this, v, this);
  }
  multiply(v) {
    return multiply(this, v, this);
  }
  multiplyScalar(scalar) {
    return multiplyScalar(this, scalar, this);
  }
  divide(v) {
    return divide(this, v, this);
  }
  dot(v) {
    return dot(this, v);
  }
  cross(v) {
    return cross(this, v);
  }
  lengthSquared() {
    return lengthSquared(this);
  }
  length() {
    return length(this);
  }
  distanceSquared(v) {
    return distanceSquared(this, v);
  }
  distance(v) {
    return distance(this, v);
  }
  normalize() {
    return normalize(this, this);
  }
  angle() {
    return angle(this);
  }
  angleDegree() {
    return angleDegree(this);
  }
  rotate(angle2) {
    return rotate(this, angle2, this);
  }
  isEqualTo(v) {
    return this.x === v.x && this.y === v.y;
  }
  clone() {
    return new Vector2D(this.x, this.y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  toArray() {
    return [this.x, this.y];
  }
}
var V = __spreadValues({
  Vector2D
}, V$1);
class VectorLine {
  constructor(source, target, v) {
    this.source = source;
    this.target = target;
    this.v = v;
  }
  static fromLinePosition(line) {
    const source = Vector2D.fromObject(line.p1);
    const target = Vector2D.fromObject(line.p2);
    return new VectorLine(source, target, toLineVector(source, target));
  }
  static fromPositions(sourcePos, targetPos) {
    const source = Vector2D.fromObject(sourcePos);
    const target = Vector2D.fromObject(targetPos);
    return new VectorLine(source, target, toLineVector(source, target));
  }
  static fromVectors(source, target) {
    return new VectorLine(source, target, toLineVector(source, target));
  }
}
function toLineVector(source, target) {
  return target.clone().subtract(source);
}
function toVectorsFromLinePosition(line) {
  return [Vector2D.fromObject(line.p1), Vector2D.fromObject(line.p2)];
}
function getCenterOfLinePosition(line) {
  return new Vector2D((line.p1.x + line.p2.x) / 2, (line.p1.y + line.p2.y) / 2);
}
function toLinePosition(p1, p2) {
  return { p1, p2 };
}
function applyMargin(linePos, sourceMargin, targetMargin) {
  const line = VectorLine.fromLinePosition(linePos);
  return applyMarginInner(line, sourceMargin, targetMargin);
}
function applyMarginInner(line, sourceMargin, targetMargin) {
  const normalized = line.v.clone().normalize();
  const sv = line.source.clone().add(normalized.clone().multiplyScalar(sourceMargin));
  const tv = line.target.clone().subtract(normalized.clone().multiplyScalar(targetMargin));
  let p1 = sv.toObject();
  let p2 = tv.toObject();
  const check = toLineVector(sv, tv);
  if (line.v.angle() * check.angle() < 0) {
    const c1 = new Vector2D((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
    const c2 = c1.clone().add(normalized.multiplyScalar(0.5));
    p1 = c1.toObject();
    p2 = c2.toObject();
  }
  return { p1, p2 };
}
function inverseLine(line) {
  return { p1: line.p2, p2: line.p1 };
}
function calculatePerpendicularLine(line) {
  const n1 = line.v.clone().normalize().rotate(Math.PI / 2);
  return VectorLine.fromVectors(line.target, line.target.clone().add(n1));
}
function getNearestPoint(p, line) {
  const n = line.v.clone().normalize();
  const lp = line.source;
  const a = V.subtract(p, lp);
  const dot2 = n.dot(a);
  const near = lp.clone().add(n.multiplyScalar(dot2));
  return near;
}
function getIntersectionOfLineTargetAndCircle(source, target, center, radius) {
  const length2 = V.lengthSquared(V.subtract(target, center));
  const contains = length2 - radius * radius <= Math.pow(1, -10);
  if (!contains)
    return null;
  const line = VectorLine.fromVectors(source, target);
  const h = getNearestPoint(center, line);
  const hpLen = V.length(V.subtract(h, center));
  if (radius < hpLen)
    return null;
  if (radius === hpLen)
    return h;
  const t = Math.sqrt(__pow(radius, 2) - __pow(hpLen, 2));
  const tv = line.v.normalize().multiplyScalar(t);
  return h.subtract(tv);
}
function getIntersectionOfLineTargetAndCircle2(source, target, center, radius, nearBy) {
  const length2 = V.lengthSquared(V.subtract(target, center));
  const contains = length2 - radius * radius <= Math.pow(1, -10);
  if (!contains)
    return null;
  const line = VectorLine.fromVectors(source, target);
  const h = getNearestPoint(center, line);
  const hpLen = V.length(V.subtract(h, center));
  if (radius < hpLen)
    return null;
  if (radius === hpLen)
    return h;
  const t = Math.sqrt(__pow(radius, 2) - __pow(hpLen, 2));
  const tv = line.v.normalize().multiplyScalar(t);
  const ip1 = h.clone().add(tv);
  const ip2 = h.clone().subtract(tv);
  const d1 = nearBy.distance(ip1);
  const d2 = nearBy.distance(ip2);
  if (Math.abs(d1 - d2) < 2) {
    return ip2;
  }
  return d1 < d2 ? ip1 : ip2;
}
function getIntersectionPointOfLines(line1, line2) {
  const v = V.subtract(line2.source, line1.source);
  const v1 = line1.v;
  const v2 = line2.v;
  const t2 = V.cross(v, v1) / V.cross(v1, v2);
  return line2.source.clone().add(v2.clone().multiplyScalar(t2));
}
function getIntersectionOfCircles(center1, radius1, center2, radius2, near) {
  const c1 = center1;
  const c2 = center2;
  const vC1C2 = c2.clone().subtract(c1);
  const a = vC1C2.length();
  const sumR = radius1 + radius2;
  if (sumR < a)
    return null;
  const subR = Math.abs(radius1 - radius2);
  if (a < subR)
    return null;
  if (a === sumR) {
    const n = vC1C2.clone().normalize();
    const p = center1.clone().add(n.multiplyScalar(radius1));
    return p;
  }
  if (a === subR) {
    const n = vC1C2.clone().normalize();
    const isLarge = radius1 > radius2;
    const p = center1.clone().add(n.multiplyScalar(isLarge ? radius1 : -radius1));
    return p;
  }
  const b = radius1;
  const c = radius2;
  const cos = (__pow(a, 2) + __pow(b, 2) - __pow(c, 2)) / (2 * a * b);
  const rc = b * cos;
  const rs = Math.sqrt(__pow(b, 2) - __pow(rc, 2));
  const n1 = vC1C2.clone().normalize();
  const n2 = new Vector2D(-n1.y, n1.x);
  const tn1 = n1.clone().multiplyScalar(rc);
  const sn2 = n2.clone().multiplyScalar(rs);
  const result1 = center1.clone().add(tn1).add(sn2);
  const result2 = center1.clone().add(tn1).subtract(sn2);
  const d1 = result1.distance(near);
  const d2 = result2.distance(near);
  return d1 < d2 ? result1 : result2;
}
function calculateDistanceToAvoidOverlapsWithRect(sourcePos, targetPos, rect, scale) {
  const centerLine = VectorLine.fromPositions(sourcePos, targetPos);
  const halfWidth = (rect.width + rect.strokeWidth) / 2 * scale;
  const halfHeight = (rect.height + rect.strokeWidth) / 2 * scale;
  const borderRadius = rect.borderRadius > 0 ? (rect.borderRadius + rect.strokeWidth / 2) * scale : 0;
  const angleVRad = (centerLine.v.angle() - Math.PI / 2) % Math.PI;
  const angleHRad = Math.PI / 2 - angleVRad % Math.PI;
  const w = halfHeight * Math.abs(Math.tan(angleVRad));
  const h = halfWidth * Math.abs(Math.tan(angleHRad));
  const isCrossedVLine = w <= halfWidth - borderRadius;
  const isCrossedHLine = h <= halfHeight - borderRadius;
  if (isCrossedVLine || isCrossedHLine || borderRadius === 0) {
    if (isCrossedVLine) {
      return Math.sqrt(__pow(halfHeight, 2) + __pow(w, 2));
    } else {
      return Math.sqrt(__pow(halfWidth, 2) + __pow(h, 2));
    }
  } else {
    const left = targetPos.x - halfWidth + borderRadius;
    const top = targetPos.y - halfHeight + borderRadius;
    const right = targetPos.x + halfWidth - borderRadius;
    const bottom = targetPos.y + halfHeight - borderRadius;
    const vertexes = [
      new Vector2D(left, top),
      new Vector2D(right, top),
      new Vector2D(right, bottom),
      new Vector2D(left, bottom)
    ];
    const index = Math.floor((centerLine.v.angleDegree() + 360) % 360 / 90);
    const centerOfNearestCircle = vertexes[index];
    const point = getIntersectionOfLineTargetAndCircle(centerLine.source, getNearestPoint(centerOfNearestCircle, centerLine), centerOfNearestCircle, borderRadius);
    return point ? toLineVector(point, centerLine.target).length() : toLineVector(centerOfNearestCircle, centerLine.target).length() + borderRadius;
  }
}
function calculateEdgeLabelArea(linePos, edgeStyle, margin, padding, scale) {
  const line = VectorLine.fromLinePosition(linePos);
  const normalized = line.v.clone().normalize();
  const sv = padding === 0 ? line.source : line.source.clone().add(normalized.clone().multiplyScalar(padding * scale));
  const tv = padding === 0 ? line.target : line.target.clone().subtract(normalized.clone().multiplyScalar(padding * scale));
  const labelMargin = (edgeStyle.width / 2 + margin) * scale;
  const vMargin = new Vector2D(-normalized.y, normalized.x).multiplyScalar(labelMargin);
  let sourceAbove = V.subtract(sv, vMargin);
  let sourceBelow = V.add(sv, vMargin);
  let targetAbove = V.subtract(tv, vMargin);
  let targetBelow = V.add(tv, vMargin);
  const angle2 = line.v.angleDegree();
  if (angle2 < -90 || angle2 >= 90) {
    [sourceAbove, sourceBelow] = [sourceBelow, sourceAbove];
    [targetAbove, targetBelow] = [targetBelow, targetAbove];
  }
  return {
    source: { above: sourceAbove, below: sourceBelow },
    target: { above: targetAbove, below: targetBelow }
  };
}
function calculateDistancesFromCenterOfNodeToEndOfNode(sourceNodePos, targetNodePos, sourceNodeShape, targetNodeShape) {
  let distance1;
  if (sourceNodeShape.type === "circle") {
    distance1 = sourceNodeShape.radius + sourceNodeShape.strokeWidth / 2;
  } else {
    distance1 = calculateDistanceToAvoidOverlapsWithRect(targetNodePos, sourceNodePos, sourceNodeShape, 1);
  }
  let distance2;
  if (targetNodeShape.type === "circle") {
    distance2 = targetNodeShape.radius + targetNodeShape.strokeWidth / 2;
  } else {
    distance2 = calculateDistanceToAvoidOverlapsWithRect(sourceNodePos, targetNodePos, targetNodeShape, 1);
  }
  return [distance1, distance2];
}
function moveOnCircumference(pos, center, radian) {
  const { x, y } = pos;
  const dx = x - center.x;
  const dy = y - center.y;
  return {
    x: dx * Math.cos(radian) - dy * Math.sin(radian) + center.x,
    y: dx * Math.sin(radian) + dy * Math.cos(radian) + center.y
  };
}
function reverseAngleRadian(theta) {
  if (theta > 0) {
    return -(Math.PI * 2 - theta);
  } else {
    return Math.PI * 2 + theta;
  }
}
function calculateBezierCurveControlPoint(p1, center, p2, theta0) {
  const control = [];
  const centerToSource = VectorLine.fromVectors(center, p1);
  const centerToTarget = VectorLine.fromVectors(center, p2);
  let theta = calculateRelativeAngleRadian(centerToSource, centerToTarget);
  if (theta0 * theta < 0) {
    theta = reverseAngleRadian(theta);
  }
  const middle = Vector2D.fromObject(moveOnCircumference(p1, center, -theta / 2));
  const centerToMp = VectorLine.fromVectors(center, middle);
  const mpTangent = calculatePerpendicularLine(centerToMp);
  const theta1 = calculateRelativeAngleRadian(centerToSource, centerToMp);
  let tangent = calculatePerpendicularLine(centerToSource);
  if (Math.abs(theta1) < Math.PI / 2) {
    const cp = getIntersectionPointOfLines(tangent, mpTangent);
    control.push(cp);
  } else {
    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta1 / 2));
    const tangent2 = calculatePerpendicularLine(VectorLine.fromVectors(center, Vector2D.fromObject(mp)));
    const cp1 = getIntersectionPointOfLines(tangent, tangent2);
    const cp2 = getIntersectionPointOfLines(tangent2, mpTangent);
    control.push(cp1, mp, cp2);
  }
  control.push(middle);
  const theta2 = calculateRelativeAngleRadian(centerToTarget, centerToMp);
  tangent = calculatePerpendicularLine(centerToTarget);
  if (Math.abs(theta2) < Math.PI / 2) {
    const cp = getIntersectionPointOfLines(tangent, mpTangent);
    control.push(cp);
  } else {
    const mp = Vector2D.fromObject(moveOnCircumference(middle, center, theta2 / 2));
    const tangent2 = calculatePerpendicularLine(VectorLine.fromVectors(center, Vector2D.fromObject(mp)));
    const cp1 = getIntersectionPointOfLines(mpTangent, tangent2);
    const cp2 = getIntersectionPointOfLines(tangent2, tangent);
    control.push(cp1, mp, cp2);
  }
  return control;
}
function calculateRelativeAngleRadian(line1, line2) {
  return Math.atan2(line1.v.y * line2.v.x - line1.v.x * line2.v.y, line1.v.x * line2.v.x + line1.v.y * line2.v.y);
}
function calculateCircleCenterAndRadiusBy3Points(p1, p2, p3) {
  const x1 = p1.x;
  const y1 = p1.y;
  const x2 = p2.x;
  const y2 = p2.y;
  const x3 = p3.x;
  const y3 = p3.y;
  const x12 = x1 - x2;
  const y12 = y1 - y2;
  const x32 = x3 - x2;
  const y32 = y3 - y2;
  const x = (y32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) - y12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) / (2 * x12 * y32 - 2 * y12 * x32);
  const y = (-x32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) + x12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) / (2 * x12 * y32 - 2 * y12 * x32);
  const radius = Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2));
  const center = new Vector2D(x, y);
  return [center, radius];
}
function convertToAscii(source) {
  if (typeof btoa === void 0) {
    return Buffer.from(source).toString("base64").replaceAll("=", "");
  } else {
    return btoa(source).replaceAll("=", "");
  }
}
function makeMarkerState() {
  const markers = reactive({});
  const referenceCount = {};
  return { markers, referenceCount };
}
function useMarker(markerState) {
  const { markers, referenceCount } = markerState;
  function addMarker(key, marker) {
    var _a;
    const m = (_a = referenceCount[key]) != null ? _a : 0;
    referenceCount[key] = m + 1;
    if (!m) {
      markers[key] = marker;
    }
  }
  function removeMarker(key) {
    var _a;
    const m = (_a = referenceCount[key]) != null ? _a : 0;
    if (m) {
      if (m - 1 === 0) {
        delete markers[key];
        delete referenceCount[key];
      } else {
        referenceCount[key] = m - 1;
      }
    }
  }
  function clearMarker(id) {
    if (id) {
      removeMarker(id);
    }
  }
  function makeMarker(marker, isSource, previousId, strokeColor, instanceId) {
    if (marker.type === "none") {
      clearMarker(previousId);
      return void 0;
    }
    if (marker.type === "custom") {
      clearMarker(previousId);
      return marker.customId;
    }
    const headMarker = toHeadMarker(marker, isSource, strokeColor);
    const id = buildKey(headMarker, instanceId);
    if (id === previousId) {
      return id;
    }
    clearMarker(previousId);
    addMarker(id, headMarker);
    return id;
  }
  return {
    makeMarker,
    clearMarker
  };
}
function toHeadMarker(marker, isSource, strokeColor) {
  var _a;
  return __spreadProps(__spreadValues({}, marker), {
    color: (_a = marker.color) != null ? _a : strokeColor,
    isSource
  });
}
function buildKey(m, instanceId) {
  const c = convertToAscii(m.color);
  const d = m.isSource ? "L" : "R";
  const u = m.units === "strokeWidth" ? "rel" : "abs";
  return `marker_${instanceId}_${m.type}_${m.width}_${m.height}_${m.margin}_${c}_${d}_${u}`;
}
function useObjectState(objects, config, selected, hovered, createState, terminateState, entriesForZOrder) {
  const states = reactive({});
  watch(() => new Set(Object.keys(objects.value)), (idSet, prev) => {
    if (!prev)
      prev = /* @__PURE__ */ new Set([]);
    for (const id of idSet) {
      if (prev.has(id))
        continue;
      createNewState(objects, states, id, false, config, createState);
    }
    for (const id of prev) {
      if (idSet.has(id))
        continue;
      selected.delete(id);
      hovered.delete(id);
      terminateState == null ? void 0 : terminateState(id, states[id]);
      delete states[id];
    }
  }, { immediate: true });
  watch(() => [...selected], (objects2, prev) => {
    const append = prev ? objects2.filter((n) => !prev.includes(n)) : objects2;
    const removed = prev ? prev.filter((n) => !objects2.includes(n)) : [];
    append.forEach((id) => {
      const state = states[id];
      if (state && !state.selected)
        state.selected = true;
    });
    removed.forEach((id) => {
      const state = states[id];
      if (state && state.selected)
        state.selected = false;
    });
  }, { immediate: true });
  watch(() => [...hovered], (nodes, prev) => {
    const append = nodes.filter((n) => !prev.includes(n));
    const removed = prev.filter((n) => !nodes.includes(n));
    append.forEach((id) => {
      const state = states[id];
      if (state && !state.hovered)
        state.hovered = true;
    });
    removed.forEach((id) => {
      const state = states[id];
      if (state && state.hovered)
        state.hovered = false;
    });
  });
  const zOrderedList = computed(() => {
    const list = entriesForZOrder ? entriesForZOrder() : Object.values(states);
    if (config.zOrder.enabled) {
      return makeZOrderedList(list, config.zOrder, hovered, selected);
    } else {
      return list;
    }
  });
  return { states, zOrderedList };
}
function createNewState(objects, states, id, selected, config, createState) {
  const stateObject = {
    id,
    selected,
    hovered: false,
    selectable: computed(() => {
      if (!objects.value[id])
        return unref(stateObject.selectable);
      return Config.value(config.selectable, objects.value[id]);
    }),
    zIndex: computed(() => {
      if (!objects.value[id])
        return unref(stateObject.zIndex);
      return Config.value(config.zOrder.zIndex, objects.value[id]);
    })
  };
  states[id] = stateObject;
  createState(objects, id, states[id]);
}
function makeZOrderedList(states, zOrder, hovered, selected) {
  if (zOrder.bringToFrontOnHover && zOrder.bringToFrontOnSelected) {
    return states.sort((a, b) => {
      const hover1 = hovered.has(a.id);
      const hover2 = hovered.has(b.id);
      if (hover1 != hover2) {
        return hover1 ? 1 : -1;
      }
      const selected1 = selected.has(a.id);
      const selected2 = selected.has(b.id);
      if (selected1 != selected2) {
        return selected1 ? 1 : -1;
      }
      return a.zIndex - b.zIndex;
    });
  } else if (zOrder.bringToFrontOnHover) {
    return states.sort((a, b) => {
      const hover1 = hovered.has(a.id);
      const hover2 = hovered.has(b.id);
      if (hover1 != hover2) {
        return hover1 ? 1 : -1;
      }
      return a.zIndex - b.zIndex;
    });
  } else if (zOrder.bringToFrontOnSelected) {
    return states.sort((a, b) => {
      const selected1 = selected.has(a.id);
      const selected2 = selected.has(b.id);
      if (selected1 != selected2) {
        return selected1 ? 1 : -1;
      }
      return a.zIndex - b.zIndex;
    });
  } else {
    return states.sort((a, b) => {
      return a.zIndex - b.zIndex;
    });
  }
}
function makeStateInput(objects, selected, hovered) {
  return {
    objects,
    selected,
    hovered
  };
}
const statesKey = Symbol("states");
const NONE_MARKER = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  units: "strokeWidth",
  color: null
};
function provideStates(nodes, edges, paths, configs, layouts, makerState, scale) {
  const summarizedEdgeStates = reactive({});
  const {
    states: nodeStates,
    zOrderedList: nodeZOrderedList
  } = useObjectState(nodes.objects, configs.node, nodes.selected, nodes.hovered, (nodes2, id, newState) => {
    createNewNodeState(nodes2, id, newState, configs.node);
  }, (nodeId, _state) => {
    const positions = layouts.nodes;
    delete positions[nodeId];
  });
  const instanceId = useId();
  const edgeGroupStates = makeEdgeGroupStates(nodes.objects, edges.objects, configs);
  const edgeEntries = ref([]);
  const {
    states: edgeStates,
    zOrderedList: edgeZOrderedList
  } = useObjectState(edges.objects, configs.edge, edges.selected, edges.hovered, (edges2, id, newState) => {
    createNewEdgeState(edges2, id, newState, configs.edge, makerState, nodeStates, edgeGroupStates, layouts.nodes, scale, instanceId);
  }, (_edgeId, state) => {
    var _a;
    (_a = state.stopWatchHandle) == null ? void 0 : _a.call(state);
  }, () => edgeEntries.value);
  watchEffect(() => {
    edgeEntries.value = createEdgeEntries(edgeGroupStates.edgeGroups, edgeStates);
  });
  watch(edgeGroupStates.edgeGroups, (_) => createSummarizedEdgeStates(summarizedEdgeStates, edgeGroupStates, configs), { immediate: true });
  const {
    states: pathStates,
    zOrderedList: pathZOrderedList
  } = useObjectState(paths.objects, configs.path, paths.selected, paths.hovered, (paths2, id, newState) => {
    const state = newState;
    state.clickable = computed(() => {
      if (!paths2.value[id])
        return false;
      return Config.value(configs.path.clickable, paths2.value[id]);
    });
    state.hoverable = computed(() => {
      if (!paths2.value[id])
        return false;
      return Config.value(configs.path.hoverable, paths2.value[id]);
    });
    state.path = paths2.value[id];
    state.edges = computed(() => {
      const path = paths2.value[id];
      return path.edges.map((edgeId) => ({ edgeId, edge: edges.objects.value[edgeId] })).filter((e) => e.edge);
    });
  });
  const states = {
    nodeStates,
    edgeStates,
    edgeGroupStates,
    summarizedEdgeStates,
    pathStates,
    layouts,
    nodeZOrderedList,
    edgeZOrderedList,
    pathZOrderedList
  };
  provide(statesKey, states);
  return states;
}
function isSummarizedEdges(item) {
  return item.summarized;
}
function useStates() {
  return nonNull(inject(statesKey), "states");
}
function getNodeShape(node, selected, hovered, config) {
  if (hovered && config.hover) {
    return Config.values(config.hover, node);
  } else {
    return getNodeStaticShape(node, selected, config);
  }
}
function getNodeStaticShape(node, selected, config) {
  if (selected && config.selected) {
    return Config.values(config.selected, node);
  } else {
    return Config.values(config.normal, node);
  }
}
function createNewNodeState(nodes, id, state, config) {
  state.shape = computed(() => {
    if (!nodes.value[id])
      return unref(state.shape);
    return getNodeShape(nodes.value[id], state.selected, state.hovered, config);
  });
  state.staticShape = computed(() => {
    if (!nodes.value[id])
      return unref(state.staticShape);
    return getNodeStaticShape(nodes.value[id], state.selected, config);
  });
  state.label = computed(() => {
    if (!nodes.value[id])
      return unref(state.label);
    return Config.values(config.label, nodes.value[id]);
  });
  state.labelText = computed(() => {
    var _a, _b;
    if (config.label.text instanceof Function) {
      return unref(state.label).text;
    } else {
      if (!nodes.value[id])
        return unref(state.labelText);
      return (_b = (_a = nodes.value[id]) == null ? void 0 : _a[unref(state.label).text]) != null ? _b : "";
    }
  });
  state.draggable = computed(() => {
    if (!nodes.value[id])
      return unref(state.draggable);
    return Config.value(config.draggable, nodes.value[id]);
  });
}
function getEdgeStroke(edge, selected, hovered, config) {
  if (selected) {
    return Config.values(config.selected, edge);
  } else if (hovered && config.hover) {
    return Config.values(config.hover, edge);
  } else {
    return Config.values(config.normal, edge);
  }
}
function toEdgeMarker(marker) {
  if (marker.type === "none") {
    return NONE_MARKER;
  } else {
    return marker;
  }
}
function createNewEdgeState(edges, id, state, config, makerState, nodeStates, edgeGroupStates, layouts, scale, instanceId) {
  const { makeMarker, clearMarker } = useMarker(makerState);
  Object.assign(state, {
    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }
  });
  const line = computed(() => {
    const edge = edges.value[id];
    const stroke = getEdgeStroke(edge, state.selected, state.hovered, config);
    if (isNaN(+stroke.width)) {
      console.warn("[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]", id, stroke.width);
      stroke.width = 1;
    }
    if (stroke.color === void 0 || stroke.color === null) {
      console.warn("[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]", id, stroke.color);
      stroke.color = "#000000";
    }
    let normalWidth = Config.value(config.normal.width, edge);
    if (isNaN(+normalWidth)) {
      normalWidth = 1;
    }
    const source = toEdgeMarker(Config.values(config.marker.source, [edge, stroke]));
    const target = toEdgeMarker(Config.values(config.marker.target, [edge, stroke]));
    return { stroke, normalWidth, source, target };
  });
  state.line = line;
  const edgeLayoutPoint = toRef(edgeGroupStates.edgeLayoutPoints, id);
  const isEdgeSummarized = toRef(edgeGroupStates.summarizedEdges, id);
  const stopCalcHandle = watchEffect(() => {
    var _a, _b, _c;
    const edge = edges.value[id];
    if (!edge)
      return;
    const source = layouts[edge == null ? void 0 : edge.source];
    const target = layouts[edge == null ? void 0 : edge.target];
    const sourceShape = (_a = nodeStates[edge == null ? void 0 : edge.source]) == null ? void 0 : _a.staticShape;
    const targetShape = (_b = nodeStates[edge == null ? void 0 : edge.target]) == null ? void 0 : _b.staticShape;
    if (!source || !target || !sourceShape || !targetShape) {
      return;
    }
    const shiftedPosition = calculateEdgeShiftedPosition(edgeLayoutPoint.value, (_c = isEdgeSummarized.value) != null ? _c : false, source, target, scale.value, config.keepOrder);
    const [sourceShapeMargin, targetShapeMargin] = calculateDistancesFromCenterOfNodeToEndOfNode(source, target, sourceShape, targetShape);
    const s = scale.value;
    state.labelPosition = applyMargin(shiftedPosition, sourceShapeMargin * s, targetShapeMargin * s);
    let sourceMargin = 0;
    let targetMargin = 0;
    const l = line.value;
    if (l.source.type !== "none") {
      const marker = l.source;
      sourceMargin = marker.margin + marker.width;
      if (marker.units === "strokeWidth") {
        sourceMargin *= l.normalWidth;
      }
    }
    if (l.target.type !== "none") {
      const marker = l.target;
      targetMargin = marker.margin + marker.width;
      if (marker.units === "strokeWidth") {
        targetMargin *= l.normalWidth;
      }
    }
    if (config.margin === null || config.margin === void 0) {
      if (l.source.type !== "none" || l.target.type !== "none") {
        sourceMargin += sourceShapeMargin;
        targetMargin += targetShapeMargin;
      }
    } else {
      sourceMargin += config.margin + sourceShapeMargin;
      targetMargin += config.margin + targetShapeMargin;
    }
    const type = config.type;
    if (type === "straight") {
      state.origin = shiftedPosition;
      state.curve = void 0;
      if (sourceMargin === 0 && targetMargin === 0) {
        state.position = state.origin;
      } else {
        state.position = applyMargin(state.origin, sourceMargin * s, targetMargin * s);
      }
    } else {
      state.origin = toLinePosition(source, target);
      const shift = edgeLayoutPoint.value ? edgeLayoutPoint.value.groupWidth / 2 - edgeLayoutPoint.value.pointInGroup : 0;
      const [position, curve] = calculateCurvePositionAndState(state.origin, shiftedPosition, shift, sourceMargin * s, targetMargin * s);
      state.position = position;
      state.curve = curve;
    }
  });
  const stopUpdateMarkerHandle = watchEffect(() => {
    if (!edges.value[id])
      return;
    state.sourceMarkerId = makeMarker(line.value.source, true, state.sourceMarkerId, line.value.stroke.color, instanceId);
    state.targetMarkerId = makeMarker(line.value.target, false, state.targetMarkerId, line.value.stroke.color, instanceId);
  });
  state.stopWatchHandle = () => {
    stopCalcHandle();
    stopUpdateMarkerHandle();
    clearMarker(state.sourceMarkerId);
    clearMarker(state.targetMarkerId);
  };
}
function createEdgeEntries(edgeGroups, edgeStates) {
  return Object.entries(edgeGroups).map(([key, group]) => {
    var _a;
    if (group.summarize) {
      return {
        id: (_a = Object.keys(group.edges)[0]) != null ? _a : key,
        summarized: true,
        key,
        group,
        zIndex: Object.keys(group.edges).map((id) => {
          var _a2, _b;
          return (_b = (_a2 = edgeStates[id]) == null ? void 0 : _a2.zIndex) != null ? _b : 0;
        }).reduce((s, z) => Math.max(s, z))
      };
    } else {
      return Object.entries(group.edges).map(([id, edge]) => {
        var _a2, _b;
        return {
          id,
          summarized: false,
          key: id,
          edge,
          zIndex: (_b = (_a2 = edgeStates[id]) == null ? void 0 : _a2.zIndex) != null ? _b : 0
        };
      });
    }
  }).flat();
}
function calculateCurvePositionAndState(originPosition, shiftedPosition, shift, sourceMargin, targetMargin) {
  const origin = VectorLine.fromLinePosition(originPosition);
  const shifted = VectorLine.fromLinePosition(shiftedPosition);
  const shiftedCenter = getCenterOfLinePosition(shiftedPosition);
  const [center, radius] = calculateCircleCenterAndRadiusBy3Points(origin.source, origin.target, shiftedCenter);
  let position;
  let curve = void 0;
  if (shift === 0) {
    if (sourceMargin === 0 && targetMargin === 0) {
      position = originPosition;
    } else {
      position = applyMargin(originPosition, sourceMargin, targetMargin);
    }
    return [position, curve];
  }
  const centerToTop = VectorLine.fromVectors(center, shiftedCenter);
  const theta0 = calculateRelativeAngleRadian(VectorLine.fromVectors(center, origin.source), centerToTop);
  if (sourceMargin === 0 && targetMargin === 0) {
    position = originPosition;
  } else {
    let sourceMoveRad = sourceMargin / radius;
    let targetMoveRad = targetMargin / radius;
    if (theta0 > 0) {
      sourceMoveRad *= -1;
      targetMoveRad *= -1;
    }
    position = toLinePosition(moveOnCircumference(origin.source, center, sourceMoveRad), moveOnCircumference(origin.target, center, -targetMoveRad));
    let theta1 = calculateRelativeAngleRadian(VectorLine.fromVectors(center, origin.source), VectorLine.fromVectors(center, origin.target));
    let theta2 = calculateRelativeAngleRadian(VectorLine.fromPositions(center, position.p1), VectorLine.fromPositions(center, position.p2));
    if (theta0 * theta1 < 0) {
      theta1 = reverseAngleRadian(theta1);
      if (theta0 * theta2 < 0) {
        theta2 = reverseAngleRadian(theta2);
      }
    }
    if (theta1 * theta2 < 0) {
      const c = shiftedCenter.clone().add(shifted.v.normalize().multiplyScalar(0.5));
      position = toLinePosition(shiftedCenter, c);
      return [position, curve];
    }
  }
  const [p1, p2] = toVectorsFromLinePosition(position);
  const control = calculateBezierCurveControlPoint(p1, center, p2, theta0).map((p) => p.toObject());
  curve = {
    center: shiftedCenter,
    theta: theta0,
    circle: { center, radius },
    control
  };
  return [position, curve];
}
function createSummarizedEdgeStates(summarizedEdgeStates, edgeGroupStates, configs) {
  const groups = edgeGroupStates.edgeGroups;
  Object.entries(groups).filter(([id, group]) => group.summarize && !(id in summarizedEdgeStates)).forEach(([id, group]) => {
    const state = { stroke: void 0 };
    state.stroke = computed(() => Config.values(configs.edge.summarized.stroke, group.edges));
    summarizedEdgeStates[id] = state;
  });
  Object.keys(summarizedEdgeStates).forEach((id) => {
    var _a;
    if (!((_a = edgeGroupStates.edgeGroups[id]) == null ? void 0 : _a.summarize)) {
      delete summarizedEdgeStates[id];
    }
  });
}
class MapUtil {
  static valueOf(map) {
    return Array.from(map.values());
  }
}
const MOUSE_MOVE_DETECTION_THRESHOLD = 3;
const TOUCH_MOVE_DETECTION_THRESHOLD = 6;
const DOUBLE_CLICK_THRESHOLD = 500;
function getPointerMoveDetectionThreshold(type) {
  return type === "touch" ? TOUCH_MOVE_DETECTION_THRESHOLD : MOUSE_MOVE_DETECTION_THRESHOLD;
}
function detectClicks(clickStates, pointerId, id, event) {
  let clickState = clickStates.get(pointerId);
  if (clickState) {
    if (clickState.id !== id) {
      clickState = void 0;
    }
  } else {
    const idAndState = Array.from(clickStates.entries()).find(([_, state]) => state.id === id);
    if (idAndState) {
      const [oldPointerId, state] = idAndState;
      clickStates.delete(oldPointerId);
      clickState = state;
    }
  }
  let clickEvent, doubleClickEvent;
  [clickState, clickEvent, doubleClickEvent] = createClickEvents(clickState, event, id);
  clickStates.set(pointerId, clickState);
  return [clickEvent, doubleClickEvent];
}
function createClickEvents(clickState, event, id) {
  const now = Date.now();
  if (clickState && now - clickState.lastTime <= DOUBLE_CLICK_THRESHOLD) {
    clickState.count++;
    clickState.lastTime = now;
  } else {
    clickState = { count: 1, lastTime: now, id };
  }
  const initDict = {
    view: window,
    screenX: event.screenX,
    screenY: event.screenY,
    clientX: event.clientX,
    clientY: event.clientY,
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey,
    button: event.button,
    buttons: event.buttons,
    detail: clickState.count
  };
  let clickEvent;
  let doubleClickEvent = void 0;
  if (event instanceof PointerEvent) {
    Object.assign(initDict, {
      pointerId: event.pointerId,
      width: event.width,
      height: event.height,
      pressure: event.pressure,
      tangentialPressure: event.tangentialPressure,
      tiltX: event.tiltX,
      tiltY: event.tiltY,
      twist: event.twist,
      pointerType: event.pointerType,
      isPrimary: event.isPrimary
    });
    clickEvent = new PointerEvent("click", initDict);
    if (clickState.count === 2) {
      doubleClickEvent = new PointerEvent("dblclick", initDict);
    }
  } else {
    clickEvent = new MouseEvent("click", initDict);
    if (clickState.count === 2) {
      doubleClickEvent = new MouseEvent("dblclick", initDict);
    }
  }
  return [clickState, clickEvent, doubleClickEvent];
}
function cleanClickState(states) {
  const now = Date.now();
  Array.from(states.entries()).filter(([_, state]) => now - state.lastTime > DOUBLE_CLICK_THRESHOLD).map(([pointerId, _]) => states.delete(pointerId));
}
function makeNodeInteractionHandlers(nodeStates, nodePositions, modes, hoveredNodes, selectedNodes, zoomLevel, emitter) {
  const state = {
    pointers: /* @__PURE__ */ new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodesPre: /* @__PURE__ */ new Set(),
    clicks: /* @__PURE__ */ new Map()
  };
  const nodePointerHandlers = {
    pointermove: handleNodePointerMoveEvent,
    pointerup: handleNodePointerUpEvent,
    pointercancel: handleNodePointerCancelEvent
  };
  function _updateFollowNodes(pointerState) {
    const isFollowed = state.follow.followedPointerId === pointerState.pointerId;
    const isSelectedNode = selectedNodes.has(pointerState.nodeId);
    const removed = !(pointerState.pointerId in state.pointers);
    if (isFollowed && removed || isFollowed && !isSelectedNode) {
      const candidate = MapUtil.valueOf(state.pointers).find((p) => selectedNodes.has(p.nodeId));
      if (!candidate) {
        state.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      pointerState = candidate;
      state.follow.followedPointerId = pointerState.pointerId;
    } else {
      const followed = state.pointers.get(state.follow.followedPointerId);
      if (!followed) {
        state.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      pointerState = followed;
    }
    if (isFollowed || isSelectedNode) {
      const userGrabs = MapUtil.valueOf(state.pointers).map((n) => n.nodeId);
      state.follow.nodeBasePositions = Object.fromEntries(Array.from(selectedNodes).filter((n) => !userGrabs.includes(n)).filter((n) => {
        var _a;
        return (_a = nodeStates[n]) == null ? void 0 : _a.draggable;
      }).map((n) => [n, _unwrapNodePosition(nodePositions, n)]));
      pointerState.dragBasePosition = __spreadValues({}, pointerState.latestPosition);
      pointerState.nodeBasePosition = _unwrapNodePosition(nodePositions, pointerState.nodeId);
    }
  }
  watch(selectedNodes, (selected) => {
    const pointerState = state.pointers.get(state.follow.followedPointerId);
    if (pointerState) {
      _updateFollowNodes(pointerState);
    }
    if (selected.size > 0 && modes.selectionMode.value !== "node") {
      modes.selectionMode.value = "node";
    } else if (selected.size === 0 && modes.selectionMode.value === "node") {
      modes.selectionMode.value = "container";
    }
  });
  watch(modes.selectionMode, (mode) => {
    if (mode !== "node") {
      selectedNodes.clear();
    }
  });
  function _calculateNodeNewPosition(pointerState, event) {
    const dx = pointerState.dragBasePosition.x - event.pageX;
    const dy = pointerState.dragBasePosition.y - event.pageY;
    const positions = state.follow.followedPointerId == pointerState.pointerId ? __spreadValues({
      [pointerState.nodeId]: pointerState.nodeBasePosition
    }, state.follow.nodeBasePositions) : { [pointerState.nodeId]: pointerState.nodeBasePosition };
    const z = zoomLevel.value;
    return Object.fromEntries(Object.entries(positions).map(([node, pos]) => [
      node,
      {
        x: pos.x - dx / z,
        y: pos.y - dy / z
      }
    ]));
  }
  function handleNodeClickEvent(node, event) {
    var _a, _b;
    if (event.isTrusted)
      return;
    if (event.shiftKey && !["container", "node"].includes(modes.selectionMode.value)) {
      return;
    }
    modes.selectionMode.value = "node";
    const selectable = (_b = (_a = nodeStates[node]) == null ? void 0 : _a.selectable) != null ? _b : false;
    if (selectable) {
      const isTouchAnySelectedNode = MapUtil.valueOf(state.pointers).filter((p) => selectedNodes.has(p.nodeId)).length > 0;
      if (event.shiftKey || isTouchAnySelectedNode) {
        if (selectedNodes.has(node)) {
          selectedNodes.delete(node);
        } else if (!(typeof selectable === "number" && selectedNodes.size >= selectable)) {
          selectedNodes.add(node);
        }
      } else if (!selectedNodes.has(node)) {
        selectedNodes.clear();
        selectedNodes.add(node);
      }
    }
    emitter.emit("node:click", { node, event });
  }
  function handleNodeDoubleClickEvent(node, event) {
    if (event.isTrusted)
      return;
    emitter.emit("node:dblclick", { node, event });
  }
  function handleNodePointerMoveEvent(event) {
    var _a;
    event.stopPropagation();
    const pointerState = state.pointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    pointerState.latestPosition = { x: event.pageX, y: event.pageY };
    pointerState.moveCounter++;
    const threshold = getPointerMoveDetectionThreshold(event.pointerType);
    if (pointerState.moveCounter <= threshold) {
      return;
    }
    if (!((_a = nodeStates[pointerState.nodeId]) == null ? void 0 : _a.draggable)) {
      return;
    }
    if (pointerState.moveCounter === threshold + 1) {
      const draggingNodes2 = _calculateNodeNewPosition(pointerState, {
        pointerId: pointerState.pointerId,
        pageX: pointerState.dragBasePosition.x,
        pageY: pointerState.dragBasePosition.y
      });
      emitter.emit("node:dragstart", draggingNodes2);
    }
    const draggingNodes = _calculateNodeNewPosition(pointerState, event);
    emitter.emit("node:pointermove", draggingNodes);
  }
  function handleNodePointerCancelEvent(event) {
    event.stopPropagation();
    let pointerState = state.pointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    for (pointerState of state.pointers.values()) {
      const node = pointerState.nodeId;
      const threshold = getPointerMoveDetectionThreshold(event.pointerType);
      const isMoved = pointerState.moveCounter > threshold;
      if (isMoved) {
        const draggingNodes = _calculateNodeNewPosition(pointerState, {
          pointerId: pointerState.pointerId,
          pageX: pointerState.latestPosition.x,
          pageY: pointerState.latestPosition.y
        });
        emitter.emit("node:dragend", draggingNodes);
      }
      emitter.emit("node:pointerup", { node, event });
    }
    state.pointers.clear();
    state.follow = { followedPointerId: -1, nodeBasePositions: {} };
    entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {
      document.removeEventListener(ev, handler);
    });
    modes.viewMode.value = "default";
  }
  function handleNodePointerUpEvent(event) {
    var _a, _b, _c;
    event.stopPropagation();
    const pointerState = state.pointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    state.pointers.delete(event.pointerId);
    const node = pointerState.nodeId;
    const threshold = getPointerMoveDetectionThreshold(event.pointerType);
    const isMoved = pointerState.moveCounter > threshold;
    if (isMoved) {
      if ((_a = nodeStates[pointerState.nodeId]) == null ? void 0 : _a.draggable) {
        const draggingNodes = _calculateNodeNewPosition(pointerState, event);
        emitter.emit("node:dragend", draggingNodes);
        emitter.emit("node:pointerup", { node, event });
      }
    } else {
      emitter.emit("node:pointerup", { node, event });
    }
    if (!isMoved) {
      const [clickEvent, doubleClickEvent] = detectClicks(state.clicks, pointerState.pointerId, node, event);
      (_b = pointerState.eventTarget) == null ? void 0 : _b.dispatchEvent(clickEvent);
      if (doubleClickEvent) {
        (_c = pointerState.eventTarget) == null ? void 0 : _c.dispatchEvent(doubleClickEvent);
      }
    }
    if (state.pointers.size === 0) {
      state.follow = { followedPointerId: -1, nodeBasePositions: {} };
      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {
        document.removeEventListener(ev, handler);
      });
      cleanClickState(state.clicks);
      modes.viewMode.value = "default";
    } else {
      _updateFollowNodes(pointerState);
    }
    hoveredNodes.clear();
    state.hoveredNodesPre.forEach(hoveredNodes.add, hoveredNodes);
  }
  function handleNodePointerDownEvent(node, event) {
    if (event.button == 2) {
      return;
    }
    event.stopPropagation();
    if (!["default", "node"].includes(modes.viewMode.value)) {
      return;
    }
    if (state.pointers.size == 0) {
      modes.viewMode.value = "node";
      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {
        document.addEventListener(ev, handler);
      });
    }
    const pointerState = {
      pointerId: event.pointerId,
      nodeId: node,
      moveCounter: 0,
      nodeBasePosition: _unwrapNodePosition(nodePositions, node),
      dragBasePosition: { x: event.pageX, y: event.pageY },
      latestPosition: { x: event.pageX, y: event.pageY },
      eventTarget: event.currentTarget
    };
    state.pointers.set(event.pointerId, pointerState);
    if (selectedNodes.has(node)) {
      if (state.follow.followedPointerId < 0) {
        state.follow.followedPointerId = event.pointerId;
        _updateFollowNodes(pointerState);
      } else {
        delete state.follow.nodeBasePositions[pointerState.nodeId];
      }
    }
    emitter.emit("node:pointerdown", { node, event });
  }
  function handleNodePointerOverEvent(node, event) {
    state.hoveredNodesPre.add(node);
    if (state.pointers.size > 0) {
      return;
    }
    hoveredNodes.add(node);
    emitter.emit("node:pointerover", { node, event });
  }
  function handleNodePointerOutEvent(node, event) {
    state.hoveredNodesPre.delete(node);
    if (state.pointers.size > 0) {
      return;
    }
    hoveredNodes.delete(node);
    emitter.emit("node:pointerout", { node, event });
  }
  function handleNodeContextMenu(node, event) {
    event.stopPropagation();
    emitter.emit("node:contextmenu", { node, event });
  }
  return {
    handleNodePointerDownEvent,
    handleNodePointerOverEvent,
    handleNodePointerOutEvent,
    handleNodeClickEvent,
    handleNodeDoubleClickEvent,
    handleNodeContextMenu
  };
}
function _unwrapNodePosition(nodes, node) {
  var _a;
  const pos = (_a = nodes[node]) != null ? _a : { x: 0, y: 0 };
  return __spreadValues({}, pos);
}
function makeEdgeInteractionHandlers(edgeStates, modes, hoveredEdges, selectedEdges, emitter) {
  const state = {
    pointers: /* @__PURE__ */ new Map(),
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  const edgePointerHandlers = {
    pointerup: handleEdgePointerUpEvent,
    pointercancel: handleEdgePointerCancelEvent
  };
  watch(selectedEdges, (selected) => {
    if (selected.size > 0 && modes.selectionMode.value !== "edge") {
      modes.selectionMode.value = "edge";
    } else if (selected.size === 0 && modes.selectionMode.value === "edge") {
      modes.selectionMode.value = "container";
    }
  });
  watch(modes.selectionMode, (mode) => {
    if (mode !== "edge") {
      selectedEdges.clear();
    }
  });
  function handleEdgePointerDownEvent(edge, event) {
    if (event.button == 2) {
      return;
    }
    event.stopPropagation();
    if (!["default", "edge"].includes(modes.viewMode.value)) {
      return;
    }
    if (state.pointers.size == 0) {
      modes.viewMode.value = "edge";
      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {
        document.addEventListener(ev, handler);
      });
      state.pointerPeekCount = 0;
    }
    state.pointerPeekCount++;
    const pointerState = {
      pointerId: event.pointerId,
      id: edge,
      eventTarget: event.currentTarget
    };
    state.pointers.set(event.pointerId, pointerState);
    emitter.emit("edge:pointerdown", _makeEdgeEventObject(edge, event));
  }
  function handleEdgePointerUpEvent(event) {
    var _a, _b;
    event.stopPropagation();
    const pointerState = state.pointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    state.pointers.delete(event.pointerId);
    const edge = pointerState.id;
    emitter.emit("edge:pointerup", _makeEdgeEventObject(edge, event));
    const [clickEvent, doubleClickEvent] = detectClicks(state.clicks, pointerState.pointerId, edge instanceof Array ? edge.join(",") : edge, event);
    (_a = pointerState.eventTarget) == null ? void 0 : _a.dispatchEvent(clickEvent);
    if (doubleClickEvent) {
      (_b = pointerState.eventTarget) == null ? void 0 : _b.dispatchEvent(doubleClickEvent);
    }
    if (state.pointers.size === 0) {
      state.pointerPeekCount = 0;
      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {
        document.removeEventListener(ev, handler);
      });
      cleanClickState(state.clicks);
      modes.viewMode.value = "default";
    }
  }
  function handleEdgePointerCancelEvent(event) {
    event.stopPropagation();
    const pointerState = state.pointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    for (const pointerState2 of state.pointers.values()) {
      const edge = pointerState2.id;
      emitter.emit("edge:pointerup", _makeEdgeEventObject(edge, event));
    }
    state.pointers.clear();
    state.pointerPeekCount = 0;
    entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {
      document.removeEventListener(ev, handler);
    });
    emitter.emit("view:mode", "default");
  }
  function handleEdgeClickEvent(edge, event) {
    var _a;
    if (event.isTrusted)
      return;
    if (event.shiftKey && !["container", "edge"].includes(modes.selectionMode.value)) {
      return;
    }
    modes.selectionMode.value = "edge";
    const edges = edge instanceof Array ? edge : [edge];
    const isTouchAnySelectedEdge = MapUtil.valueOf(state.pointers).filter((p) => {
      const edges2 = p.id instanceof Array ? p.id : [p.id];
      return edges2.every((edge2) => selectedEdges.has(edge2));
    }).length > 0;
    if (edge instanceof Array) {
      const selectableEdges = edges.find((edge2) => {
        var _a2;
        return (_a2 = edgeStates[edge2]) == null ? void 0 : _a2.selectable;
      });
      if (selectableEdges) {
        if (event.shiftKey || isTouchAnySelectedEdge) {
          if (edges.some((edge2) => selectedEdges.has(edge2))) {
            edges.forEach((edge2) => selectedEdges.delete(edge2));
          } else {
            edges.forEach((edge2) => {
              var _a2;
              const selectable = (_a2 = edgeStates[edge2]) == null ? void 0 : _a2.selectable;
              if (!(typeof selectable === "number" && selectedEdges.size >= selectable)) {
                selectedEdges.add(edge2);
              }
            });
          }
        } else {
          selectedEdges.clear();
          edges.forEach((edge2) => selectedEdges.add(edge2));
        }
      }
    } else {
      const selectable = (_a = edgeStates[edge]) == null ? void 0 : _a.selectable;
      if (selectable) {
        if (event.shiftKey || isTouchAnySelectedEdge) {
          if (selectedEdges.has(edge)) {
            selectedEdges.delete(edge);
          } else if (!(typeof selectable === "number" && selectedEdges.size >= selectable)) {
            selectedEdges.add(edge);
          }
        } else if (!selectedEdges.has(edge)) {
          selectedEdges.clear();
          selectedEdges.add(edge);
        }
      }
    }
    emitter.emit("edge:click", _makeEdgeEventObject(edge, event));
  }
  function handleEdgeDoubleClickEvent(edge, event) {
    if (event.isTrusted)
      return;
    emitter.emit("edge:dblclick", _makeEdgeEventObject(edge, event));
  }
  function handleEdgePointerOverEvent(edge, event) {
    hoveredEdges.add(edge);
    emitter.emit("edge:pointerover", _makeEdgeEventObject(edge, event));
  }
  function handleEdgePointerOutEvent(edge, event) {
    hoveredEdges.delete(edge);
    emitter.emit("edge:pointerout", _makeEdgeEventObject(edge, event));
  }
  function handleEdgeContextMenu(edge, event) {
    event.stopPropagation();
    emitter.emit("edge:contextmenu", _makeEdgeEventObject(edge, event));
  }
  function handleEdgesPointerDownEvent(edges, event) {
    if (event.button == 2) {
      return;
    }
    event.stopPropagation();
    if (!["default", "edge"].includes(modes.viewMode.value)) {
      return;
    }
    if (state.pointers.size == 0) {
      modes.viewMode.value = "edge";
      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {
        document.addEventListener(ev, handler);
      });
      state.pointerPeekCount = 0;
    }
    state.pointerPeekCount++;
    const pointerState = {
      pointerId: event.pointerId,
      id: edges,
      eventTarget: event.currentTarget
    };
    state.pointers.set(event.pointerId, pointerState);
    emitter.emit("edge:pointerdown", _makeEdgeEventObject(edges, event));
  }
  function handleEdgesPointerOverEvent(edges, event) {
    edges.forEach((edge) => hoveredEdges.add(edge));
    emitter.emit("edge:pointerover", _makeEdgeEventObject(edges, event));
  }
  function handleEdgesPointerOutEvent(edges, event) {
    edges.forEach((edge) => hoveredEdges.delete(edge));
    emitter.emit("edge:pointerout", _makeEdgeEventObject(edges, event));
  }
  function handleEdgesClickEvent(edges, event) {
    handleEdgeClickEvent(edges, event);
  }
  function handleEdgesDoubleClickEvent(edges, event) {
    handleEdgeDoubleClickEvent(edges, event);
  }
  function handleEdgesContextMenu(edges, event) {
    event.stopPropagation();
    emitter.emit("edge:contextmenu", _makeEdgeEventObject(edges, event));
  }
  return {
    handleEdgePointerDownEvent,
    handleEdgePointerOverEvent,
    handleEdgePointerOutEvent,
    handleEdgeClickEvent,
    handleEdgeDoubleClickEvent,
    handleEdgeContextMenu,
    handleEdgesPointerDownEvent,
    handleEdgesPointerOverEvent,
    handleEdgesPointerOutEvent,
    handleEdgesClickEvent,
    handleEdgesDoubleClickEvent,
    handleEdgesContextMenu
  };
}
function _makeEdgeEventObject(edge, event) {
  if (edge instanceof Array) {
    return {
      edges: edge,
      event,
      summarized: true
    };
  } else {
    return {
      edge,
      edges: [edge],
      event,
      summarized: false
    };
  }
}
function setupContainerInteractionHandlers(container, modes, isSvgWheelZoomEnabled, emitter) {
  const state = {
    moveCounter: 0,
    pointerCounter: 0,
    clickState: void 0
  };
  const containerPointerHandlers = {
    pointermove: handleContainerPointerMoveEvent,
    pointerup: handleContainerPointerUpEvent,
    pointercancel: handleContainerPointerUpEvent
  };
  function handleContainerPointerDownEvent(_) {
    state.moveCounter = 0;
    if (state.pointerCounter === 0) {
      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {
        document.addEventListener(ev, handler, { passive: true });
      });
    }
    state.pointerCounter++;
  }
  function handleContainerPointerMoveEvent(_) {
    state.moveCounter++;
  }
  function handleContainerPointerUpEvent(event) {
    state.pointerCounter--;
    if (state.pointerCounter <= 0) {
      state.pointerCounter = 0;
      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {
        document.removeEventListener(ev, handler);
      });
      const threshold = getPointerMoveDetectionThreshold(event.pointerType);
      if (state.moveCounter <= threshold) {
        if (event.shiftKey && modes.selectionMode.value !== "container") {
          return;
        }
        modes.selectionMode.value = "container";
        const [clickState, clickEvent, doubleClickEvent] = createClickEvents(state.clickState, event, "view");
        state.clickState = clickState;
        container.value.dispatchEvent(clickEvent);
        if (doubleClickEvent) {
          container.value.dispatchEvent(doubleClickEvent);
        }
      }
    }
  }
  function handleContainerClickEvent(event) {
    if (event.isTrusted)
      return;
    event.stopPropagation();
    emitter.emit("view:click", { event });
  }
  function handleContainerDoubleClickEvent(event) {
    if (event.isTrusted)
      return;
    event.stopPropagation();
    emitter.emit("view:dblclick", { event });
  }
  function handleContainerContextMenuEvent(event) {
    emitter.emit("view:contextmenu", { event });
    if (state.pointerCounter > 0) {
      state.pointerCounter = 0;
      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {
        var _a;
        (_a = container.value) == null ? void 0 : _a.removeEventListener(ev, handler);
      });
    }
  }
  const preventDefault = (e) => {
    e.preventDefault();
  };
  onMounted(() => {
    const c = container.value;
    if (!c)
      return;
    c.addEventListener("pointerdown", handleContainerPointerDownEvent, { passive: true });
    c.addEventListener("click", handleContainerClickEvent, { passive: false });
    c.addEventListener("dblclick", handleContainerDoubleClickEvent, { passive: false });
    c.addEventListener("contextmenu", handleContainerContextMenuEvent, { passive: false });
    if (isSvgWheelZoomEnabled.value) {
      c.addEventListener("wheel", preventDefault, { passive: false });
    }
  });
  onUnmounted(() => {
    const c = container.value;
    if (!c)
      return;
    c.removeEventListener("pointerdown", handleContainerPointerDownEvent);
    c.removeEventListener("click", handleContainerClickEvent);
    c.removeEventListener("dblclick", handleContainerDoubleClickEvent);
    c.removeEventListener("contextmenu", handleContainerContextMenuEvent);
    if (isSvgWheelZoomEnabled.value) {
      c.removeEventListener("wheel", preventDefault);
    }
  });
  watch(isSvgWheelZoomEnabled, (enabled, old) => {
    const c = container.value;
    if (!c || enabled === old)
      return;
    if (enabled) {
      c.addEventListener("wheel", preventDefault, { passive: false });
    } else {
      c.removeEventListener("wheel", preventDefault);
    }
  });
}
function makePathInteractionHandlers(pathStates, modes, hoveredPaths, selectedPaths, isInCompatibilityModeForPath, emitter) {
  const state = {
    pointers: /* @__PURE__ */ new Map(),
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  function _makePathEventObject(path, event) {
    var _a, _b;
    if (isInCompatibilityModeForPath.value) {
      return { path: (_b = (_a = pathStates[path]) == null ? void 0 : _a.path) != null ? _b : path, event };
    } else {
      return { path, event };
    }
  }
  const pathPointerHandlers = {
    pointerup: handlePathPointerUpEvent,
    pointercancel: handlePathPointerCancelEvent
  };
  watch(selectedPaths, (selected) => {
    if (selected.size > 0 && modes.selectionMode.value !== "path") {
      modes.selectionMode.value = "path";
    } else if (selected.size === 0 && modes.selectionMode.value === "path") {
      modes.selectionMode.value = "container";
    }
  });
  watch(modes.selectionMode, (mode) => {
    if (mode !== "path") {
      selectedPaths.clear();
    }
  });
  function handlePathPointerDownEvent(path, event) {
    var _a;
    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {
      return;
    }
    if (event.button == 2) {
      return;
    }
    event.stopPropagation();
    if (!["default", "path"].includes(modes.viewMode.value)) {
      return;
    }
    if (state.pointers.size == 0) {
      modes.viewMode.value = "path";
      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {
        document.addEventListener(ev, handler);
      });
      state.pointerPeekCount = 0;
    }
    state.pointerPeekCount++;
    const pointerState = {
      pointerId: event.pointerId,
      id: path,
      eventTarget: event.currentTarget
    };
    state.pointers.set(event.pointerId, pointerState);
    emitter.emit("path:pointerdown", _makePathEventObject(path, event));
  }
  function handlePathPointerUpEvent(event) {
    var _a, _b;
    const pointerState = state.pointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    event.stopPropagation();
    state.pointers.delete(event.pointerId);
    const path = pointerState.id;
    emitter.emit("path:pointerup", _makePathEventObject(path, event));
    const [clickEvent, doubleClickEvent] = detectClicks(state.clicks, pointerState.pointerId, path, event);
    (_a = pointerState.eventTarget) == null ? void 0 : _a.dispatchEvent(clickEvent);
    if (doubleClickEvent) {
      (_b = pointerState.eventTarget) == null ? void 0 : _b.dispatchEvent(doubleClickEvent);
    }
    if (state.pointers.size === 0) {
      state.pointerPeekCount = 0;
      entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {
        document.removeEventListener(ev, handler);
      });
      cleanClickState(state.clicks);
      modes.viewMode.value = "default";
    }
  }
  function handlePathPointerCancelEvent(event) {
    const pointerState = state.pointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    event.stopPropagation();
    for (const pointerState2 of state.pointers.values()) {
      const path = pointerState2.id;
      emitter.emit("path:pointerup", _makePathEventObject(path, event));
    }
    state.pointers.clear();
    state.pointerPeekCount = 0;
    entriesOf(pathPointerHandlers).forEach(([ev, handler]) => {
      document.removeEventListener(ev, handler);
    });
    emitter.emit("view:mode", "default");
  }
  function handlePathPointerOverEvent(path, event) {
    var _a;
    if (!((_a = pathStates[path]) == null ? void 0 : _a.hoverable)) {
      return;
    }
    hoveredPaths.add(path);
    emitter.emit("path:pointerover", _makePathEventObject(path, event));
  }
  function handlePathPointerOutEvent(path, event) {
    var _a;
    if (!((_a = pathStates[path]) == null ? void 0 : _a.hoverable)) {
      return;
    }
    hoveredPaths.delete(path);
    emitter.emit("path:pointerout", _makePathEventObject(path, event));
  }
  function handlePathClickEvent(path, event) {
    var _a, _b, _c;
    if (event.isTrusted)
      return;
    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {
      return;
    }
    if (event.shiftKey && !["container", "path"].includes(modes.selectionMode.value)) {
      return;
    }
    modes.selectionMode.value = "path";
    const selectable = (_c = (_b = pathStates[path]) == null ? void 0 : _b.selectable) != null ? _c : false;
    if (selectable) {
      const isTouchAnySelectedPath = MapUtil.valueOf(state.pointers).filter((p) => selectedPaths.has(p.id)).length > 0;
      if (event.shiftKey || isTouchAnySelectedPath) {
        if (selectedPaths.has(path)) {
          selectedPaths.delete(path);
        } else if (!(typeof selectable === "number" && selectedPaths.size >= selectable)) {
          selectedPaths.add(path);
        }
      } else if (!selectedPaths.has(path)) {
        selectedPaths.clear();
        selectedPaths.add(path);
      }
    }
    emitter.emit("path:click", _makePathEventObject(path, event));
  }
  function handlePathDoubleClickEvent(path, event) {
    var _a;
    if (event.isTrusted)
      return;
    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {
      return;
    }
    emitter.emit("path:dblclick", _makePathEventObject(path, event));
  }
  function handlePathContextMenu(path, event) {
    var _a;
    if (!((_a = pathStates[path]) == null ? void 0 : _a.clickable)) {
      return;
    }
    event.stopPropagation();
    emitter.emit("path:contextmenu", _makePathEventObject(path, event));
  }
  return {
    handlePathPointerDownEvent,
    handlePathPointerOverEvent,
    handlePathPointerOutEvent,
    handlePathClickEvent,
    handlePathDoubleClickEvent,
    handlePathContextMenu
  };
}
const mouseEventHandlersKey = Symbol("mouseEventHandlers");
function provideMouseOperation(container, nodePositions, zoomLevel, nodeStates, edgeStates, pathStates, selectedNodes, selectedEdges, selectedPaths, hoveredNodes, hoveredEdges, hoveredPaths, isInCompatibilityModeForPath, isSvgWheelZoomEnabled, emitter) {
  const modes = {
    selectionMode: ref("container"),
    viewMode: ref("default")
  };
  if (selectedNodes.size > 0) {
    modes.selectionMode.value = "node";
  } else if (selectedEdges.size > 0) {
    modes.selectionMode.value = "edge";
  } else if (selectedPaths.size > 0) {
    modes.selectionMode.value = "path";
  }
  watch(modes.viewMode, (mode) => {
    emitter.emit("view:mode", mode);
  });
  setupContainerInteractionHandlers(container, modes, isSvgWheelZoomEnabled, emitter);
  const provides = __spreadValues(__spreadValues(__spreadValues({
    selectedNodes,
    hoveredNodes,
    selectedEdges,
    hoveredEdges,
    selectedPaths,
    hoveredPaths
  }, makeNodeInteractionHandlers(nodeStates, nodePositions, modes, hoveredNodes, selectedNodes, zoomLevel, emitter)), makeEdgeInteractionHandlers(edgeStates, modes, hoveredEdges, selectedEdges, emitter)), makePathInteractionHandlers(pathStates, modes, hoveredPaths, selectedPaths, isInCompatibilityModeForPath, emitter));
  provide(mouseEventHandlersKey, provides);
  return provides;
}
function useMouseOperation() {
  return nonNull(inject(mouseEventHandlersKey), "mouseEventHandlers");
}
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
const eventEmitterKey = Symbol("emitter");
function provideEventEmitter() {
  const emitter = mitt();
  provide(eventEmitterKey, emitter);
  return emitter;
}
function useEventEmitter() {
  return nonNull(inject(eventEmitterKey), "event emitter");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var utilities = {
  getGlobalThis: function() {
    if (typeof globalThis !== "undefined")
      return globalThis;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    if (typeof this !== "undefined")
      return this;
    throw new Error("Unable to locate global `this`");
  },
  extend: function(target, source) {
    target = target || {};
    for (var prop in source) {
      if (this.isObject(source[prop])) {
        target[prop] = this.extend(target[prop], source[prop]);
      } else {
        target[prop] = source[prop];
      }
    }
    return target;
  },
  isElement: function(o) {
    return o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
  },
  isObject: function(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  },
  isNumber: function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  },
  getSvg: function(elementOrSelector) {
    var element, svg;
    if (!this.isElement(elementOrSelector)) {
      if (typeof elementOrSelector === "string" || elementOrSelector instanceof String) {
        element = document.querySelector(elementOrSelector);
        if (!element) {
          throw new Error("Provided selector did not find any elements. Selector: " + elementOrSelector);
        }
      } else {
        throw new Error("Provided selector is not an HTML object nor String");
      }
    } else {
      element = elementOrSelector;
    }
    if (element.tagName.toLowerCase() === "svg") {
      svg = element;
    } else {
      if (element.tagName.toLowerCase() === "object") {
        svg = element.contentDocument.documentElement;
      } else {
        if (element.tagName.toLowerCase() === "embed") {
          svg = element.getSVGDocument().documentElement;
        } else {
          if (element.tagName.toLowerCase() === "img") {
            throw new Error('Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.');
          } else {
            throw new Error("Cannot get SVG.");
          }
        }
      }
    }
    return svg;
  },
  proxy: function(fn, context) {
    return function() {
      return fn.apply(context, arguments);
    };
  },
  getType: function(o) {
    return Object.prototype.toString.apply(o).replace(/^\[object\s/, "").replace(/\]$/, "");
  },
  mouseAndTouchNormalize: function(evt, svg) {
    if (evt.clientX === void 0 || evt.clientX === null) {
      evt.clientX = 0;
      evt.clientY = 0;
      if (evt.touches !== void 0 && evt.touches.length) {
        if (evt.touches[0].clientX !== void 0) {
          evt.clientX = evt.touches[0].clientX;
          evt.clientY = evt.touches[0].clientY;
        } else if (evt.touches[0].pageX !== void 0) {
          var rect = svg.getBoundingClientRect();
          evt.clientX = evt.touches[0].pageX - rect.left;
          evt.clientY = evt.touches[0].pageY - rect.top;
        }
      } else if (evt.originalEvent !== void 0) {
        if (evt.originalEvent.clientX !== void 0) {
          evt.clientX = evt.originalEvent.clientX;
          evt.clientY = evt.originalEvent.clientY;
        }
      }
    }
  },
  touchNormalize: function(evt, svg, touch) {
    if (evt.touches !== void 0 && evt.touches.length) {
      if (evt.touches[touch].clientX !== void 0) {
        evt.clientX = evt.touches[touch].clientX;
        evt.clientY = evt.touches[touch].clientY;
      } else if (evt.touches[touch].pageX !== void 0) {
        var rect = svg.getBoundingClientRect();
        evt.clientX = evt.touches[touch].pageX - rect.left;
        evt.clientY = evt.touches[touch].pageY - rect.top;
      }
    } else {
      if (evt.clientX === void 0 || evt.clientX === null) {
        evt.clientX = 0;
        evt.clientY = 0;
        if (evt.originalEvent !== void 0) {
          if (evt.originalEvent.clientX !== void 0) {
            evt.clientX = evt.originalEvent.clientX;
            evt.clientY = evt.originalEvent.clientY;
          }
        }
      }
    }
  },
  isDblClick: function(evt, prevEvt) {
    if (evt.detail === 2) {
      return true;
    } else if (prevEvt !== void 0 && prevEvt !== null) {
      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2));
      return timeStampDiff < 250 && touchesDistance < 10;
    }
    return false;
  },
  now: Date.now || function() {
    return new Date().getTime();
  },
  throttle: function(func, wait, options) {
    var that = this;
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) {
      options = {};
    }
    var later = function() {
      previous = options.leading === false ? 0 : that.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) {
        context = args = null;
      }
    };
    return function() {
      var now = that.now();
      if (!previous && options.leading === false) {
        previous = now;
      }
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        if (!timeout) {
          context = args = null;
        }
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  },
  createRequestAnimationFrame: function(refreshRate) {
    var timeout = null;
    if (refreshRate !== "auto" && refreshRate < 60 && refreshRate > 1) {
      timeout = Math.floor(1e3 / refreshRate);
    }
    if (timeout === null) {
      return window.requestAnimationFrame || requestTimeout(33);
    } else {
      return requestTimeout(timeout);
    }
  },
  calculateDistance: function(point1, point2) {
    var dx = point1.x - point2.x;
    var dy = point1.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
};
function requestTimeout(timeout) {
  return function(callback) {
    window.setTimeout(callback, timeout);
  };
}
var Utils$3 = utilities;
var uniwheel = function() {
  var prefix = "", _addEventListener, _removeEventListener, support, fns = [];
  var passiveTrueOption = { passive: true };
  var passiveFalseOption = { passive: false };
  if (Utils$3.getGlobalThis().addEventListener) {
    _addEventListener = "addEventListener";
    _removeEventListener = "removeEventListener";
  } else {
    _addEventListener = "attachEvent";
    _removeEventListener = "detachEvent";
    prefix = "on";
  }
  function getSupport() {
    if (!support) {
      support = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    }
    return support;
  }
  function createCallback(element, callback) {
    var fn = function(originalEvent) {
      !originalEvent && (originalEvent = window.event);
      var event = {
        originalEvent,
        target: originalEvent.target || originalEvent.srcElement,
        type: "wheel",
        deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;
        }
      };
      if (getSupport() == "mousewheel") {
        event.deltaY = -1 / 40 * originalEvent.wheelDelta;
        originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX);
      } else {
        event.deltaY = originalEvent.detail;
      }
      return callback(event);
    };
    fns.push({
      element,
      fn
    });
    return fn;
  }
  function getCallback(element) {
    for (var i = 0; i < fns.length; i++) {
      if (fns[i].element === element) {
        return fns[i].fn;
      }
    }
    return function() {
    };
  }
  function removeCallback(element) {
    for (var i = 0; i < fns.length; i++) {
      if (fns[i].element === element) {
        return fns.splice(i, 1);
      }
    }
  }
  function _addWheelListener(elem, eventName, callback, isPassiveListener) {
    var cb;
    if (getSupport() === "wheel") {
      cb = callback;
    } else {
      cb = createCallback(elem, callback);
    }
    elem[_addEventListener](prefix + eventName, cb, isPassiveListener ? passiveTrueOption : passiveFalseOption);
  }
  function _removeWheelListener(elem, eventName, callback, isPassiveListener) {
    var cb;
    if (getSupport() === "wheel") {
      cb = callback;
    } else {
      cb = getCallback(elem);
    }
    elem[_removeEventListener](prefix + eventName, cb, isPassiveListener ? passiveTrueOption : passiveFalseOption);
    removeCallback(elem);
  }
  function addWheelListener(elem, callback, isPassiveListener) {
    _addWheelListener(elem, getSupport(), callback, isPassiveListener);
    if (getSupport() == "DOMMouseScroll") {
      _addWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
    }
  }
  function removeWheelListener(elem, callback, isPassiveListener) {
    _removeWheelListener(elem, getSupport(), callback, isPassiveListener);
    if (getSupport() == "DOMMouseScroll") {
      _removeWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
    }
  }
  return {
    on: addWheelListener,
    off: removeWheelListener
  };
}();
var Utils$2 = utilities, _browser = "unknown";
if (typeof document != "undefined" && !!document.documentMode) {
  _browser = "ie";
}
var svgUtilities = {
  svgNS: "http://www.w3.org/2000/svg",
  xmlNS: "http://www.w3.org/XML/1998/namespace",
  xmlnsNS: "http://www.w3.org/2000/xmlns/",
  xlinkNS: "http://www.w3.org/1999/xlink",
  evNS: "http://www.w3.org/2001/xml-events",
  getBoundingClientRectNormalized: function(svg) {
    if (svg.clientWidth && svg.clientHeight) {
      return { width: svg.clientWidth, height: svg.clientHeight };
    } else if (!!svg.getBoundingClientRect()) {
      return svg.getBoundingClientRect();
    } else {
      throw new Error("Cannot get BoundingClientRect for SVG.");
    }
  },
  getOrCreateViewport: function(svg, selector) {
    var viewport = null;
    if (Utils$2.isElement(selector)) {
      viewport = selector;
    } else {
      viewport = svg.querySelector(selector);
    }
    if (!viewport) {
      var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function(el) {
        return el.nodeName !== "defs" && el.nodeName !== "#text";
      });
      if (childNodes.length === 1 && childNodes[0].nodeName === "g" && childNodes[0].getAttribute("transform") === null) {
        viewport = childNodes[0];
      }
    }
    if (!viewport) {
      var viewportId = "viewport-" + new Date().toISOString().replace(/\D/g, "");
      viewport = document.createElementNS(this.svgNS, "g");
      viewport.setAttribute("id", viewportId);
      var svgChildren = svg.childNodes || svg.children;
      if (!!svgChildren && svgChildren.length > 0) {
        for (var i = svgChildren.length; i > 0; i--) {
          if (svgChildren[svgChildren.length - i].nodeName !== "defs") {
            viewport.appendChild(svgChildren[svgChildren.length - i]);
          }
        }
      }
      svg.appendChild(viewport);
    }
    var classNames = [];
    if (viewport.getAttribute("class")) {
      classNames = viewport.getAttribute("class").split(" ");
    }
    if (!~classNames.indexOf("svg-pan-zoom_viewport")) {
      classNames.push("svg-pan-zoom_viewport");
      viewport.setAttribute("class", classNames.join(" "));
    }
    return viewport;
  },
  setupSvgAttributes: function(svg) {
    svg.setAttribute("xmlns", this.svgNS);
    svg.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS);
    svg.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS);
    if (svg.parentNode !== null) {
      var style = svg.getAttribute("style") || "";
      if (style.toLowerCase().indexOf("overflow") === -1) {
        svg.setAttribute("style", "overflow: hidden; " + style);
      }
    }
  },
  internetExplorerRedisplayInterval: 300,
  refreshDefsGlobal: Utils$2.throttle(function() {
    var allDefs = document.querySelectorAll("defs");
    var allDefsCount = allDefs.length;
    for (var i = 0; i < allDefsCount; i++) {
      var thisDefs = allDefs[i];
      thisDefs.parentNode.insertBefore(thisDefs, thisDefs);
    }
  }, commonjsGlobal ? commonjsGlobal.internetExplorerRedisplayInterval : null),
  setCTM: function(element, matrix, defs) {
    var that = this, s = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
    element.setAttributeNS(null, "transform", s);
    if ("transform" in element.style) {
      element.style.transform = s;
    } else if ("-ms-transform" in element.style) {
      element.style["-ms-transform"] = s;
    } else if ("-webkit-transform" in element.style) {
      element.style["-webkit-transform"] = s;
    }
    if (_browser === "ie" && !!defs) {
      defs.parentNode.insertBefore(defs, defs);
      window.setTimeout(function() {
        that.refreshDefsGlobal();
      }, that.internetExplorerRedisplayInterval);
    }
  },
  getEventPoint: function(evt, svg) {
    var point = svg.createSVGPoint();
    Utils$2.mouseAndTouchNormalize(evt, svg);
    point.x = evt.clientX;
    point.y = evt.clientY;
    return point;
  },
  getTouchPoint: function(evt, svg, touch) {
    var point = svg.createSVGPoint();
    Utils$2.touchNormalize(evt, svg, touch);
    point.x = evt.clientX;
    point.y = evt.clientY;
    return point;
  },
  getSvgCenterPoint: function(svg, width, height) {
    return this.createSVGPoint(svg, width / 2, height / 2);
  },
  createSVGPoint: function(svg, x, y) {
    var point = svg.createSVGPoint();
    point.x = x;
    point.y = y;
    return point;
  }
};
var SvgUtils$2 = svgUtilities;
var controlIcons = {
  enable: function(instance) {
    var defs = instance.svg.querySelector("defs");
    if (!defs) {
      defs = document.createElementNS(SvgUtils$2.svgNS, "defs");
      instance.svg.appendChild(defs);
    }
    var styleEl = defs.querySelector("style#svg-pan-zoom-controls-styles");
    if (!styleEl) {
      var style = document.createElementNS(SvgUtils$2.svgNS, "style");
      style.setAttribute("id", "svg-pan-zoom-controls-styles");
      style.setAttribute("type", "text/css");
      style.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }";
      defs.appendChild(style);
    }
    var zoomGroup = document.createElementNS(SvgUtils$2.svgNS, "g");
    zoomGroup.setAttribute("id", "svg-pan-zoom-controls");
    zoomGroup.setAttribute("transform", "translate(" + (instance.width - 70) + " " + (instance.height - 76) + ") scale(0.75)");
    zoomGroup.setAttribute("class", "svg-pan-zoom-control");
    zoomGroup.appendChild(this._createZoomIn(instance));
    zoomGroup.appendChild(this._createZoomReset(instance));
    zoomGroup.appendChild(this._createZoomOut(instance));
    instance.svg.appendChild(zoomGroup);
    instance.controlIcons = zoomGroup;
  },
  _createZoomIn: function(instance) {
    var zoomIn = document.createElementNS(SvgUtils$2.svgNS, "g");
    zoomIn.setAttribute("id", "svg-pan-zoom-zoom-in");
    zoomIn.setAttribute("transform", "translate(30.5 5) scale(0.015)");
    zoomIn.setAttribute("class", "svg-pan-zoom-control");
    zoomIn.addEventListener("click", function() {
      instance.getPublicInstance().zoomIn();
    }, false);
    zoomIn.addEventListener("touchstart", function() {
      instance.getPublicInstance().zoomIn();
    }, false);
    var zoomInBackground = document.createElementNS(SvgUtils$2.svgNS, "rect");
    zoomInBackground.setAttribute("x", "0");
    zoomInBackground.setAttribute("y", "0");
    zoomInBackground.setAttribute("width", "1500");
    zoomInBackground.setAttribute("height", "1400");
    zoomInBackground.setAttribute("class", "svg-pan-zoom-control-background");
    zoomIn.appendChild(zoomInBackground);
    var zoomInShape = document.createElementNS(SvgUtils$2.svgNS, "path");
    zoomInShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z");
    zoomInShape.setAttribute("class", "svg-pan-zoom-control-element");
    zoomIn.appendChild(zoomInShape);
    return zoomIn;
  },
  _createZoomReset: function(instance) {
    var resetPanZoomControl = document.createElementNS(SvgUtils$2.svgNS, "g");
    resetPanZoomControl.setAttribute("id", "svg-pan-zoom-reset-pan-zoom");
    resetPanZoomControl.setAttribute("transform", "translate(5 35) scale(0.4)");
    resetPanZoomControl.setAttribute("class", "svg-pan-zoom-control");
    resetPanZoomControl.addEventListener("click", function() {
      instance.getPublicInstance().reset();
    }, false);
    resetPanZoomControl.addEventListener("touchstart", function() {
      instance.getPublicInstance().reset();
    }, false);
    var resetPanZoomControlBackground = document.createElementNS(SvgUtils$2.svgNS, "rect");
    resetPanZoomControlBackground.setAttribute("x", "2");
    resetPanZoomControlBackground.setAttribute("y", "2");
    resetPanZoomControlBackground.setAttribute("width", "182");
    resetPanZoomControlBackground.setAttribute("height", "58");
    resetPanZoomControlBackground.setAttribute("class", "svg-pan-zoom-control-background");
    resetPanZoomControl.appendChild(resetPanZoomControlBackground);
    var resetPanZoomControlShape1 = document.createElementNS(SvgUtils$2.svgNS, "path");
    resetPanZoomControlShape1.setAttribute("d", "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z");
    resetPanZoomControlShape1.setAttribute("class", "svg-pan-zoom-control-element");
    resetPanZoomControl.appendChild(resetPanZoomControlShape1);
    var resetPanZoomControlShape2 = document.createElementNS(SvgUtils$2.svgNS, "path");
    resetPanZoomControlShape2.setAttribute("d", "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z");
    resetPanZoomControlShape2.setAttribute("class", "svg-pan-zoom-control-element");
    resetPanZoomControl.appendChild(resetPanZoomControlShape2);
    return resetPanZoomControl;
  },
  _createZoomOut: function(instance) {
    var zoomOut = document.createElementNS(SvgUtils$2.svgNS, "g");
    zoomOut.setAttribute("id", "svg-pan-zoom-zoom-out");
    zoomOut.setAttribute("transform", "translate(30.5 70) scale(0.015)");
    zoomOut.setAttribute("class", "svg-pan-zoom-control");
    zoomOut.addEventListener("click", function() {
      instance.getPublicInstance().zoomOut();
    }, false);
    zoomOut.addEventListener("touchstart", function() {
      instance.getPublicInstance().zoomOut();
    }, false);
    var zoomOutBackground = document.createElementNS(SvgUtils$2.svgNS, "rect");
    zoomOutBackground.setAttribute("x", "0");
    zoomOutBackground.setAttribute("y", "0");
    zoomOutBackground.setAttribute("width", "1500");
    zoomOutBackground.setAttribute("height", "1400");
    zoomOutBackground.setAttribute("class", "svg-pan-zoom-control-background");
    zoomOut.appendChild(zoomOutBackground);
    var zoomOutShape = document.createElementNS(SvgUtils$2.svgNS, "path");
    zoomOutShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z");
    zoomOutShape.setAttribute("class", "svg-pan-zoom-control-element");
    zoomOut.appendChild(zoomOutShape);
    return zoomOut;
  },
  disable: function(instance) {
    if (instance.controlIcons) {
      instance.controlIcons.parentNode.removeChild(instance.controlIcons);
      instance.controlIcons = null;
    }
  }
};
var SvgUtils$1 = svgUtilities, Utils$1 = utilities;
var ShadowViewport$1 = function(viewport, options) {
  this.init(viewport, options);
};
ShadowViewport$1.prototype.init = function(viewport, options) {
  this.viewport = viewport;
  this.options = options;
  this.originalState = { zoom: 1, x: 0, y: 0 };
  this.activeState = { zoom: 1, x: 0, y: 0 };
  this.updateCTMCached = Utils$1.proxy(this.updateCTM, this);
  this.requestAnimationFrame = Utils$1.createRequestAnimationFrame(this.options.refreshRate);
  this.viewBox = { x: 0, y: 0, width: 0, height: 0 };
  this.cacheViewBox();
  var newCTM = this.processCTM();
  this.setCTM(newCTM);
  this.updateCTM();
};
ShadowViewport$1.prototype.cacheViewBox = function() {
  var svgViewBox = this.options.svg.getAttribute("viewBox");
  if (svgViewBox) {
    var viewBoxValues = svgViewBox.split(/[\s\,]/).filter(function(v) {
      return v;
    }).map(parseFloat);
    this.viewBox.x = viewBoxValues[0];
    this.viewBox.y = viewBoxValues[1];
    this.viewBox.width = viewBoxValues[2];
    this.viewBox.height = viewBoxValues[3];
    var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
    this.activeState.zoom = zoom;
    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;
    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;
    this.updateCTMOnNextFrame();
    this.options.svg.removeAttribute("viewBox");
  } else {
    this.simpleViewBoxCache();
  }
};
ShadowViewport$1.prototype.simpleViewBoxCache = function() {
  var bBox = this.viewport.getBBox();
  this.viewBox.x = bBox.x;
  this.viewBox.y = bBox.y;
  this.viewBox.width = bBox.width;
  this.viewBox.height = bBox.height;
};
ShadowViewport$1.prototype.getViewBox = function() {
  return Utils$1.extend({}, this.viewBox);
};
ShadowViewport$1.prototype.processCTM = function() {
  var newCTM = this.getCTM();
  if (this.options.fit || this.options.contain) {
    var newScale;
    if (this.options.fit) {
      newScale = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
    } else {
      newScale = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
    }
    newCTM.a = newScale;
    newCTM.d = newScale;
    newCTM.e = -this.viewBox.x * newScale;
    newCTM.f = -this.viewBox.y * newScale;
  }
  if (this.options.center) {
    var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * 0.5, offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * 0.5;
    newCTM.e = offsetX;
    newCTM.f = offsetY;
  }
  this.originalState.zoom = newCTM.a;
  this.originalState.x = newCTM.e;
  this.originalState.y = newCTM.f;
  return newCTM;
};
ShadowViewport$1.prototype.getOriginalState = function() {
  return Utils$1.extend({}, this.originalState);
};
ShadowViewport$1.prototype.getState = function() {
  return Utils$1.extend({}, this.activeState);
};
ShadowViewport$1.prototype.getZoom = function() {
  return this.activeState.zoom;
};
ShadowViewport$1.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom;
};
ShadowViewport$1.prototype.computeRelativeZoom = function(scale) {
  return scale / this.originalState.zoom;
};
ShadowViewport$1.prototype.getPan = function() {
  return { x: this.activeState.x, y: this.activeState.y };
};
ShadowViewport$1.prototype.getCTM = function() {
  var safeCTM = this.options.svg.createSVGMatrix();
  safeCTM.a = this.activeState.zoom;
  safeCTM.b = 0;
  safeCTM.c = 0;
  safeCTM.d = this.activeState.zoom;
  safeCTM.e = this.activeState.x;
  safeCTM.f = this.activeState.y;
  return safeCTM;
};
ShadowViewport$1.prototype.setCTM = function(newCTM) {
  var willZoom = this.isZoomDifferent(newCTM), willPan = this.isPanDifferent(newCTM);
  if (willZoom || willPan) {
    if (willZoom) {
      if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {
        newCTM.a = newCTM.d = this.activeState.zoom;
        willZoom = false;
      } else {
        this.updateCache(newCTM);
        this.options.onZoom(this.getRelativeZoom());
      }
    }
    if (willPan) {
      var preventPan = this.options.beforePan(this.getPan(), {
        x: newCTM.e,
        y: newCTM.f
      }), preventPanX = false, preventPanY = false;
      if (preventPan === false) {
        newCTM.e = this.getPan().x;
        newCTM.f = this.getPan().y;
        preventPanX = preventPanY = true;
      } else if (Utils$1.isObject(preventPan)) {
        if (preventPan.x === false) {
          newCTM.e = this.getPan().x;
          preventPanX = true;
        } else if (Utils$1.isNumber(preventPan.x)) {
          newCTM.e = preventPan.x;
        }
        if (preventPan.y === false) {
          newCTM.f = this.getPan().y;
          preventPanY = true;
        } else if (Utils$1.isNumber(preventPan.y)) {
          newCTM.f = preventPan.y;
        }
      }
      if (preventPanX && preventPanY || !this.isPanDifferent(newCTM)) {
        willPan = false;
      } else {
        this.updateCache(newCTM);
        this.options.onPan(this.getPan());
      }
    }
    if (willZoom || willPan) {
      this.updateCTMOnNextFrame();
    }
  }
};
ShadowViewport$1.prototype.isZoomDifferent = function(newCTM) {
  return this.activeState.zoom !== newCTM.a;
};
ShadowViewport$1.prototype.isPanDifferent = function(newCTM) {
  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;
};
ShadowViewport$1.prototype.updateCache = function(newCTM) {
  this.activeState.zoom = newCTM.a;
  this.activeState.x = newCTM.e;
  this.activeState.y = newCTM.f;
};
ShadowViewport$1.prototype.pendingUpdate = false;
ShadowViewport$1.prototype.updateCTMOnNextFrame = function() {
  if (!this.pendingUpdate) {
    this.pendingUpdate = true;
    this.requestAnimationFrame.call(window, this.updateCTMCached);
  }
};
ShadowViewport$1.prototype.updateCTM = function() {
  var ctm = this.getCTM();
  SvgUtils$1.setCTM(this.viewport, ctm, this.defs);
  this.pendingUpdate = false;
  if (this.options.onUpdatedCTM) {
    this.options.onUpdatedCTM(ctm);
  }
};
var shadowViewport = function(viewport, options) {
  return new ShadowViewport$1(viewport, options);
};
var Wheel = uniwheel, ControlIcons = controlIcons, Utils = utilities, SvgUtils = svgUtilities, ShadowViewport = shadowViewport;
var SvgPanZoom = function(svg, options) {
  this.init(svg, options);
};
var optionsDefaults = {
  viewportSelector: ".svg-pan-zoom_viewport",
  panEnabled: true,
  controlIconsEnabled: false,
  zoomEnabled: true,
  dblClickZoomEnabled: true,
  mouseWheelZoomEnabled: true,
  preventMouseEventsDefault: true,
  zoomScaleSensitivity: 0.1,
  minZoom: 0.5,
  maxZoom: 10,
  fit: true,
  contain: false,
  center: true,
  refreshRate: "auto",
  beforeZoom: null,
  onZoom: null,
  beforePan: null,
  onPan: null,
  customEventsHandler: null,
  eventsListenerElement: null,
  onUpdatedCTM: null
};
var passiveListenerTrueOption = { passive: true };
var passiveListenerFalseOption = { passive: false };
SvgPanZoom.prototype.init = function(svg, options) {
  var that = this;
  this.svg = svg;
  this.defs = svg.querySelector("defs");
  SvgUtils.setupSvgAttributes(this.svg);
  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);
  this.state = "none";
  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg);
  this.width = boundingClientRectNormalized.width;
  this.height = boundingClientRectNormalized.height;
  this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {
    svg: this.svg,
    width: this.width,
    height: this.height,
    fit: this.options.fit,
    contain: this.options.contain,
    center: this.options.center,
    refreshRate: this.options.refreshRate,
    beforeZoom: function(oldScale, newScale) {
      if (that.viewport && that.options.beforeZoom) {
        return that.options.beforeZoom(oldScale, newScale);
      }
    },
    onZoom: function(scale) {
      if (that.viewport && that.options.onZoom) {
        return that.options.onZoom(scale);
      }
    },
    beforePan: function(oldPoint, newPoint) {
      if (that.viewport && that.options.beforePan) {
        return that.options.beforePan(oldPoint, newPoint);
      }
    },
    onPan: function(point) {
      if (that.viewport && that.options.onPan) {
        return that.options.onPan(point);
      }
    },
    onUpdatedCTM: function(ctm) {
      if (that.viewport && that.options.onUpdatedCTM) {
        return that.options.onUpdatedCTM(ctm);
      }
    }
  });
  var publicInstance = this.getPublicInstance();
  publicInstance.setBeforeZoom(this.options.beforeZoom);
  publicInstance.setOnZoom(this.options.onZoom);
  publicInstance.setBeforePan(this.options.beforePan);
  publicInstance.setOnPan(this.options.onPan);
  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);
  if (this.options.controlIconsEnabled) {
    ControlIcons.enable(this);
  }
  this.lastMouseWheelEventTime = Date.now();
  this.setupHandlers();
};
SvgPanZoom.prototype.setupHandlers = function() {
  var that = this, prevEvt = null;
  this.eventListeners = {
    pointerdown: function(evt) {
      if (evt.pointerType === "touch")
        return;
      var result = that.handleMouseDown(evt, prevEvt);
      prevEvt = evt;
      return result;
    },
    touchstart: function(evt) {
      var result = that.handleTouchStart(evt, prevEvt);
      prevEvt = evt;
      return result;
    },
    pointerup: function(evt) {
      if (evt.pointerType === "touch")
        return;
      return that.handleMouseUp(evt);
    },
    touchend: function(evt) {
      return that.handleTouchEnd(evt);
    },
    pointermove: function(evt) {
      if (evt.pointerType === "touch")
        return;
      return that.handleMouseMove(evt);
    },
    touchmove: function(evt) {
      return that.handleTouchMove(evt);
    },
    pointerleave: function(evt) {
      if (evt.pointerType === "touch")
        return;
      return that.handleMouseUp(evt);
    },
    pointercancel: function(evt) {
      if (evt.pointerType === "touch")
        return;
      return that.handleMouseUp(evt);
    },
    touchleave: function(evt) {
      return that.handleTouchEnd(evt);
    },
    touchcancel: function(evt) {
      return that.handleTouchEnd(evt);
    }
  };
  if (this.options.customEventsHandler != null) {
    this.options.customEventsHandler.init({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    var haltEventListeners = this.options.customEventsHandler.haltEventListeners;
    if (haltEventListeners && haltEventListeners.length) {
      for (var i = haltEventListeners.length - 1; i >= 0; i--) {
        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {
          delete this.eventListeners[haltEventListeners[i]];
        }
      }
    }
  }
  for (var event in this.eventListeners) {
    (this.options.eventsListenerElement || this.svg).addEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerTrueOption : passiveListenerFalseOption);
  }
  if (this.options.mouseWheelZoomEnabled) {
    this.options.mouseWheelZoomEnabled = false;
    this.enableMouseWheelZoom();
  }
};
SvgPanZoom.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var that = this;
    this.wheelListener = function(evt) {
      return that.handleMouseWheel(evt);
    };
    var isPassiveListener = !this.options.preventMouseEventsDefault;
    Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
    this.options.mouseWheelZoomEnabled = true;
  }
};
SvgPanZoom.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    var isPassiveListener = !this.options.preventMouseEventsDefault;
    Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
    this.options.mouseWheelZoomEnabled = false;
  }
};
SvgPanZoom.prototype.handleMouseWheel = function(evt) {
  if (!this.options.zoomEnabled || this.state !== "none") {
    return;
  }
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  var delta = evt.deltaY || 1, timeDelta = Date.now() - this.lastMouseWheelEventTime, divider = 3 + Math.max(0, 30 - timeDelta);
  this.lastMouseWheelEventTime = Date.now();
  if ("deltaMode" in evt && evt.deltaMode === 0 && evt.wheelDelta) {
    delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;
  }
  delta = -0.3 < delta && delta < 0.3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider;
  var inversedScreenCTM = this.svg.getScreenCTM().inverse(), relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM), zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta);
  this.zoomAtPoint(zoom, relativeMousePoint);
};
SvgPanZoom.prototype.zoomAtPoint = function(zoomScale, point, zoomAbsolute) {
  var originalState = this.viewport.getOriginalState();
  if (!zoomAbsolute) {
    if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {
      zoomScale = this.options.minZoom * originalState.zoom / this.getZoom();
    } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {
      zoomScale = this.options.maxZoom * originalState.zoom / this.getZoom();
    }
  } else {
    zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale));
    zoomScale = zoomScale / this.getZoom();
  }
  var oldCTM = this.viewport.getCTM(), relativePoint = point.matrixTransform(oldCTM.inverse()), modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y), newCTM = oldCTM.multiply(modifier);
  if (newCTM.a !== oldCTM.a) {
    this.viewport.setCTM(newCTM);
  }
};
SvgPanZoom.prototype.zoom = function(scale, absolute) {
  this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute);
};
SvgPanZoom.prototype.publicZoom = function(scale, absolute) {
  if (absolute) {
    scale = this.computeFromRelativeZoom(scale);
  }
  this.zoom(scale, absolute);
};
SvgPanZoom.prototype.publicZoomAtPoint = function(scale, point, absolute) {
  if (absolute) {
    scale = this.computeFromRelativeZoom(scale);
  }
  if (Utils.getType(point) !== "SVGPoint") {
    if ("x" in point && "y" in point) {
      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);
    } else {
      throw new Error("Given point is invalid");
    }
  }
  this.zoomAtPoint(scale, point, absolute);
};
SvgPanZoom.prototype.getZoom = function() {
  return this.viewport.getZoom();
};
SvgPanZoom.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom();
};
SvgPanZoom.prototype.computeFromRelativeZoom = function(zoom) {
  return zoom * this.viewport.getOriginalState().zoom;
};
SvgPanZoom.prototype.resetZoom = function() {
  var originalState = this.viewport.getOriginalState();
  this.zoom(originalState.zoom, true);
};
SvgPanZoom.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
};
SvgPanZoom.prototype.reset = function() {
  this.resetZoom();
  this.resetPan();
};
SvgPanZoom.prototype.handleDblClick = function(evt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  if (this.options.controlIconsEnabled) {
    var targetClass = evt.target.getAttribute("class") || "";
    if (targetClass.indexOf("svg-pan-zoom-control") > -1) {
      return false;
    }
  }
  var zoomFactor;
  if (evt.shiftKey) {
    zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2);
  } else {
    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;
  }
  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());
  this.zoomAtPoint(zoomFactor, point);
};
SvgPanZoom.prototype.handleMouseDown = function(evt, prevEvt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  Utils.mouseAndTouchNormalize(evt, this.svg);
  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {
    this.handleDblClick(evt);
  } else {
    this.state = "pan";
    this.firstEventCTM = this.viewport.getCTM();
    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());
  }
};
SvgPanZoom.prototype.handleMouseMove = function(evt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  if (this.state === "pan" && this.options.panEnabled) {
    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse()), viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);
    this.viewport.setCTM(viewportCTM);
  }
};
SvgPanZoom.prototype.handleMouseUp = function(evt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  if (this.state === "pan") {
    this.state = "none";
  }
};
SvgPanZoom.prototype.handleTouchStart = function(evt, prevEvt) {
  if (evt.touches.length == 1) {
    this.handleMouseDown(evt, prevEvt);
  } else {
    if (this.options.preventMouseEventsDefault) {
      if (evt.preventDefault) {
        evt.preventDefault();
      } else {
        evt.returnValue = false;
      }
    }
    this.firstEventCTM = this.viewport.getCTM();
    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);
    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);
    this.firstDistance = Utils.calculateDistance(touch1, touch2);
    touch1.x = (touch1.x + touch2.x) / 2;
    touch1.y = (touch1.y + touch2.y) / 2;
    this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());
    this.firstZoomLevel = this.getZoom();
  }
};
SvgPanZoom.prototype.handleTouchMove = function(evt) {
  if (evt.touches.length == 1) {
    this.handleMouseMove(evt);
  } else {
    if (this.options.preventMouseEventsDefault) {
      if (evt.preventDefault) {
        evt.preventDefault();
      } else {
        evt.returnValue = false;
      }
    }
    if (!this.options.panEnabled && !this.options.zoomEnabled) {
      return;
    }
    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);
    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);
    var center = this.svg.createSVGPoint();
    center.x = (touch1.x + touch2.x) / 2;
    center.y = (touch1.y + touch2.y) / 2;
    if (this.state === "pan" && this.options.panEnabled) {
      var point = center.matrixTransform(this.firstEventCTM.inverse());
      var viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);
      this.viewport.setCTM(viewportCTM);
    }
    if (this.options.zoomEnabled) {
      var distance2 = Utils.calculateDistance(touch1, touch2);
      var scale = distance2 / this.firstDistance;
      var inversedScreenCTM = this.svg.getScreenCTM().inverse();
      var relativeTouchPoint = center.matrixTransform(inversedScreenCTM);
      this.zoomAtPoint(this.firstZoomLevel * scale, relativeTouchPoint, true);
    }
  }
};
SvgPanZoom.prototype.handleTouchEnd = function(evt) {
  if (evt.touches.length == 0) {
    this.handleMouseUp(evt);
  } else {
    if (this.options.preventMouseEventsDefault) {
      if (evt.preventDefault) {
        evt.preventDefault();
      } else {
        evt.returnValue = false;
      }
    }
    this.firstEventCTM = this.viewport.getCTM();
    if (evt.touches.length == 1) {
      this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());
    } else {
      var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);
      var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);
      this.firstDistance = Utils.calculateDistance(touch1, touch2);
      touch1.x = (touch1.x + touch2.x) / 2;
      touch1.y = (touch1.y + touch2.y) / 2;
      this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());
    }
  }
};
SvgPanZoom.prototype.fit = function() {
  var viewBox = this.viewport.getViewBox(), newScale = Math.min(this.width / viewBox.width, this.height / viewBox.height);
  this.zoom(newScale, true);
};
SvgPanZoom.prototype.contain = function() {
  var viewBox = this.viewport.getViewBox(), newScale = Math.max(this.width / viewBox.width, this.height / viewBox.height);
  this.zoom(newScale, true);
};
SvgPanZoom.prototype.center = function() {
  var viewBox = this.viewport.getViewBox(), offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5, offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;
  this.getPublicInstance().pan({ x: offsetX, y: offsetY });
};
SvgPanZoom.prototype.updateBBox = function() {
  this.viewport.simpleViewBoxCache();
};
SvgPanZoom.prototype.pan = function(point) {
  var viewportCTM = this.viewport.getCTM();
  viewportCTM.e = point.x;
  viewportCTM.f = point.y;
  this.viewport.setCTM(viewportCTM);
};
SvgPanZoom.prototype.panBy = function(point) {
  var viewportCTM = this.viewport.getCTM();
  viewportCTM.e += point.x;
  viewportCTM.f += point.y;
  this.viewport.setCTM(viewportCTM);
};
SvgPanZoom.prototype.getPan = function() {
  var state = this.viewport.getState();
  return { x: state.x, y: state.y };
};
SvgPanZoom.prototype.resize = function() {
  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg);
  this.width = boundingClientRectNormalized.width;
  this.height = boundingClientRectNormalized.height;
  var viewport = this.viewport;
  viewport.options.width = this.width;
  viewport.options.height = this.height;
  viewport.processCTM();
  if (this.options.controlIconsEnabled) {
    this.getPublicInstance().disableControlIcons();
    this.getPublicInstance().enableControlIcons();
  }
};
SvgPanZoom.prototype.destroy = function() {
  var that = this;
  this.beforeZoom = null;
  this.onZoom = null;
  this.beforePan = null;
  this.onPan = null;
  this.onUpdatedCTM = null;
  if (this.options.customEventsHandler != null) {
    this.options.customEventsHandler.destroy({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
  }
  for (var event in this.eventListeners) {
    (this.options.eventsListenerElement || this.svg).removeEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerTrueOption : passiveListenerFalseOption);
  }
  this.disableMouseWheelZoom();
  this.getPublicInstance().disableControlIcons();
  instancesStore = instancesStore.filter(function(instance) {
    return instance.svg !== that.svg;
  });
  delete this.options;
  delete this.viewport;
  delete this.publicInstance;
  delete this.pi;
  this.getPublicInstance = function() {
    return null;
  };
};
SvgPanZoom.prototype.getPublicInstance = function() {
  var that = this;
  if (!this.publicInstance) {
    this.publicInstance = this.pi = {
      enablePan: function() {
        that.options.panEnabled = true;
        return that.pi;
      },
      disablePan: function() {
        that.options.panEnabled = false;
        return that.pi;
      },
      isPanEnabled: function() {
        return !!that.options.panEnabled;
      },
      pan: function(point) {
        that.pan(point);
        return that.pi;
      },
      panBy: function(point) {
        that.panBy(point);
        return that.pi;
      },
      getPan: function() {
        return that.getPan();
      },
      setBeforePan: function(fn) {
        that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      setOnPan: function(fn) {
        that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      enableZoom: function() {
        that.options.zoomEnabled = true;
        return that.pi;
      },
      disableZoom: function() {
        that.options.zoomEnabled = false;
        return that.pi;
      },
      isZoomEnabled: function() {
        return !!that.options.zoomEnabled;
      },
      enableControlIcons: function() {
        if (!that.options.controlIconsEnabled) {
          that.options.controlIconsEnabled = true;
          ControlIcons.enable(that);
        }
        return that.pi;
      },
      disableControlIcons: function() {
        if (that.options.controlIconsEnabled) {
          that.options.controlIconsEnabled = false;
          ControlIcons.disable(that);
        }
        return that.pi;
      },
      isControlIconsEnabled: function() {
        return !!that.options.controlIconsEnabled;
      },
      enableDblClickZoom: function() {
        that.options.dblClickZoomEnabled = true;
        return that.pi;
      },
      disableDblClickZoom: function() {
        that.options.dblClickZoomEnabled = false;
        return that.pi;
      },
      isDblClickZoomEnabled: function() {
        return !!that.options.dblClickZoomEnabled;
      },
      enableMouseWheelZoom: function() {
        that.enableMouseWheelZoom();
        return that.pi;
      },
      disableMouseWheelZoom: function() {
        that.disableMouseWheelZoom();
        return that.pi;
      },
      isMouseWheelZoomEnabled: function() {
        return !!that.options.mouseWheelZoomEnabled;
      },
      setZoomScaleSensitivity: function(scale) {
        that.options.zoomScaleSensitivity = scale;
        return that.pi;
      },
      setMinZoom: function(zoom) {
        that.options.minZoom = zoom;
        return that.pi;
      },
      setMaxZoom: function(zoom) {
        that.options.maxZoom = zoom;
        return that.pi;
      },
      setBeforeZoom: function(fn) {
        that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      setOnZoom: function(fn) {
        that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      zoom: function(scale) {
        that.publicZoom(scale, true);
        return that.pi;
      },
      zoomBy: function(scale) {
        that.publicZoom(scale, false);
        return that.pi;
      },
      zoomAtPoint: function(scale, point) {
        that.publicZoomAtPoint(scale, point, true);
        return that.pi;
      },
      zoomAtPointBy: function(scale, point) {
        that.publicZoomAtPoint(scale, point, false);
        return that.pi;
      },
      zoomIn: function() {
        this.zoomBy(1 + that.options.zoomScaleSensitivity);
        return that.pi;
      },
      zoomOut: function() {
        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));
        return that.pi;
      },
      getZoom: function() {
        return that.getRelativeZoom();
      },
      setOnUpdatedCTM: function(fn) {
        that.options.onUpdatedCTM = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      resetZoom: function() {
        that.resetZoom();
        return that.pi;
      },
      resetPan: function() {
        that.resetPan();
        return that.pi;
      },
      reset: function() {
        that.reset();
        return that.pi;
      },
      fit: function() {
        that.fit();
        return that.pi;
      },
      contain: function() {
        that.contain();
        return that.pi;
      },
      center: function() {
        that.center();
        return that.pi;
      },
      updateBBox: function() {
        that.updateBBox();
        return that.pi;
      },
      resize: function() {
        that.resize();
        return that.pi;
      },
      getSizes: function() {
        return {
          width: that.width,
          height: that.height,
          realZoom: that.getZoom(),
          viewBox: that.viewport.getViewBox()
        };
      },
      destroy: function() {
        that.destroy();
        return that.pi;
      }
    };
  }
  return this.publicInstance;
};
var instancesStore = [];
var svgPanZoom = function(elementOrSelector, options) {
  var svg = Utils.getSvg(elementOrSelector);
  if (svg === null) {
    return null;
  } else {
    for (var i = instancesStore.length - 1; i >= 0; i--) {
      if (instancesStore[i].svg === svg) {
        return instancesStore[i].instance.getPublicInstance();
      }
    }
    instancesStore.push({
      svg,
      instance: new SvgPanZoom(svg, options)
    });
    return instancesStore[instancesStore.length - 1].instance.getPublicInstance();
  }
};
var svgPanZoom_1 = svgPanZoom;
const methods = {
  fitToContents() {
    this.fit().center().zoomOut().zoomOut();
    return this;
  },
  getViewArea() {
    const sizes = this.getSizes();
    const pan = this.getPan();
    const scale = sizes.realZoom;
    pan.x /= scale;
    pan.y /= scale;
    const viewport = {
      width: sizes.width / scale,
      height: sizes.height / scale
    };
    return {
      box: {
        top: -pan.y,
        bottom: viewport.height - pan.y,
        left: -pan.x,
        right: viewport.width - pan.x
      },
      center: {
        x: viewport.width / 2 - pan.x,
        y: viewport.height / 2 - pan.y
      }
    };
  },
  getViewBox() {
    return this.getViewArea().box;
  },
  setViewBox(box) {
    const width = box.right - box.left;
    const height = box.bottom - box.top;
    const { width: sizeWidth, height: sizeHeight } = this.getSizes();
    const ratio = width / height;
    const currentRatio = sizeWidth / sizeHeight;
    const newWidth = ratio < currentRatio ? height * currentRatio : width;
    const newHeight = ratio > currentRatio ? width / currentRatio : height;
    const absoluteZoom = Math.min(sizeWidth / newWidth, sizeHeight / newHeight);
    const realZoom = this.getRealZoom();
    const relativeZoom = this.getZoom();
    const originalZoom = realZoom / relativeZoom;
    this.zoom(absoluteZoom / originalZoom);
    const center = {
      x: (box.left + width / 2) * absoluteZoom,
      y: (box.top + height / 2) * absoluteZoom
    };
    this.pan({
      x: -center.x + newWidth / 2 * absoluteZoom,
      y: -center.y + newHeight / 2 * absoluteZoom
    });
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(zoomLevel, minZoomLevel, maxZoomLevel) {
    const min = Math.max(1e-4, minZoomLevel);
    const max = Math.max(min, maxZoomLevel);
    const zoom = Math.max(Math.min(max, zoomLevel), min);
    const realZoom = this.getRealZoom();
    const relativeZoom = this.getZoom();
    const originalZoom = realZoom / relativeZoom;
    this.setMinZoom(min / originalZoom).setMaxZoom(max / originalZoom).zoom(zoom / originalZoom);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    this._isPanEnabled = true;
    this._internalEnablePan();
    return this;
  },
  disablePan() {
    this._isPanEnabled = false;
    this._internalDisablePan();
    return this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    this._isZoomEnabled = true;
    this._internalEnableZoom();
    return this;
  },
  disableZoom() {
    this._isZoomEnabled = false;
    this._internalDisableZoom();
    return this;
  },
  setPanEnabled(enabled) {
    if (enabled) {
      this.enablePan();
    } else {
      this.disablePan();
    }
    return this;
  },
  setZoomEnabled(enabled) {
    if (enabled) {
      this.enableZoom();
      this.enableDblClickZoom();
    } else {
      this.disableZoom();
      this.disableDblClickZoom();
    }
    return this;
  }
};
function constructor(svgPanZoom2, options) {
  var _a, _b;
  const instance = svgPanZoom2;
  instance._isPanEnabled = (_a = options.panEnabled) != null ? _a : true;
  instance._isZoomEnabled = (_b = options == null ? void 0 : options.zoomEnabled) != null ? _b : true;
  instance._internalIsPanEnabled = instance.isPanEnabled;
  instance._internalEnablePan = instance.enablePan;
  instance._internalDisablePan = instance.disablePan;
  instance._internalIsZoomEnabled = instance.isZoomEnabled;
  instance._internalEnableZoom = instance.enableZoom;
  instance._internalDisableZoom = instance.disableZoom;
  Object.assign(svgPanZoom2, methods);
  return instance;
}
function createSvgPanZoomEx(svg, options) {
  var _a, _b, _c, _d, _e, _f;
  const userInit = (_b = (_a = options.customEventsHandler) == null ? void 0 : _a.init) != null ? _b : (_) => {
  };
  const userDestroy = (_d = (_c = options.customEventsHandler) == null ? void 0 : _c.destroy) != null ? _d : (_) => {
  };
  const haltEventListeners = (_f = (_e = options.customEventsHandler) == null ? void 0 : _e.haltEventListeners) != null ? _f : [];
  if (options.mouseWheelZoomEnabled === void 0) {
    options.mouseWheelZoomEnabled = options.zoomEnabled;
  }
  options.customEventsHandler = {
    init: (o) => {
      constructor(o.instance, options);
      userInit(o);
    },
    destroy: (o) => userDestroy(o),
    haltEventListeners
  };
  return svgPanZoom_1(svg, options);
}
function useSvgPanZoom(svg, options) {
  const instance = ref();
  let state = 0;
  const mountedCallbacks = [];
  const unmountedCallbacks = [];
  const instanceMounted = () => {
    state = 1;
    mountedCallbacks.forEach((c) => c());
    mountedCallbacks.length = 0;
  };
  const instanceUnmounted = () => {
    state = 2;
    unmountedCallbacks.forEach((c) => c());
    unmountedCallbacks.length = 0;
  };
  onMounted(() => {
    var _a, _b, _c, _d, _e, _f;
    const element = nonNull(svg.value, "<svg>");
    const userInit = (_b = (_a = options.customEventsHandler) == null ? void 0 : _a.init) != null ? _b : (_) => {
    };
    const userDestroy = (_d = (_c = options.customEventsHandler) == null ? void 0 : _c.destroy) != null ? _d : (_) => {
    };
    const haltEventListeners = (_f = (_e = options.customEventsHandler) == null ? void 0 : _e.haltEventListeners) != null ? _f : [];
    options.customEventsHandler = {
      init: (o) => {
        instance.value = o.instance;
        userInit(o);
        instanceMounted();
      },
      destroy: (o) => {
        instanceUnmounted();
        userDestroy(o);
      },
      haltEventListeners
    };
    const initialize = () => {
      const rect = element.getBoundingClientRect();
      if (rect.width !== 0 && rect.height !== 0) {
        createSvgPanZoomEx(element, options);
      } else {
        setTimeout(initialize, 200);
      }
    };
    initialize();
  });
  onUnmounted(() => {
    var _a;
    (_a = instance.value) == null ? void 0 : _a.destroy();
    instance.value = void 0;
  });
  const onSvgPanZoomMounted = (callback) => {
    if (state === 0) {
      mountedCallbacks.push(callback);
    } else if (state === 1) {
      callback();
    }
  };
  const onSvgPanZoomUnmounted = (callback) => {
    if (state === 0 || state === 1) {
      unmountedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  return { svgPanZoom: instance, onSvgPanZoomMounted, onSvgPanZoomUnmounted };
}
const zoomLevelKey = Symbol("zoomLevel");
function provideZoomLevel(zoomLevel, viewStyle) {
  const scale = computed(() => {
    return viewStyle.scalingObjects ? 1 : 1 / zoomLevel.value;
  });
  provide(zoomLevelKey, {
    zoomLevel,
    scale
  });
  return { scale };
}
function useZoomLevel() {
  return nonNull(inject(zoomLevelKey), "zoomLevel");
}
function isPromise(obj) {
  return obj instanceof Promise || obj && typeof obj.then === "function";
}
function useTransitionWhile() {
  let timerId = null;
  const transitionOption = ref({
    enabled: false,
    duration: 300,
    timingFunction: "linear"
  });
  function transitionWhile(func, duration = 300, timingFunction = "linear") {
    if (timerId) {
      clearTimeout(timerId);
      timerId = null;
    }
    transitionOption.value = {
      enabled: true,
      duration,
      timingFunction
    };
    nextTick(() => __async(this, null, function* () {
      const promise = func();
      if (isPromise(promise)) {
        yield promise;
      }
      if (timerId) {
        clearTimeout(timerId);
      }
      timerId = window == null ? void 0 : window.setTimeout(() => {
        transitionOption.value.enabled = false;
        timerId = null;
      }, duration);
    }));
  }
  return { transitionWhile, transitionOption };
}
function useTranslatePathsToObject(input) {
  const objects = ref({});
  const isInCompatibilityModeForPath = ref(false);
  let nextId2 = 1;
  const idStore = /* @__PURE__ */ new Map();
  watchEffect(() => {
    if (input.value instanceof Array) {
      const containKeys = /* @__PURE__ */ new Set([]);
      objects.value = Object.fromEntries(input.value.map((path) => {
        let id = path.id;
        if (!id) {
          if (!isInCompatibilityModeForPath.value) {
            isInCompatibilityModeForPath.value = true;
            console.warn("[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required.");
          }
          id = idStore.get(path);
          if (!id) {
            id = "path-" + nextId2++;
            idStore.set(path, id);
          }
        }
        containKeys.add(id);
        return [id, path];
      }));
      if (isInCompatibilityModeForPath.value) {
        for (const [path, id] of Array.from(idStore.entries())) {
          if (!containKeys.has(id)) {
            idStore.delete(path);
          }
        }
      }
    } else {
      objects.value = input.value;
    }
  });
  return { objects, isInCompatibilityModeForPath };
}
function bindProp(props, name, emit, filter) {
  if (filter) {
    const prop2 = ref(filter(props[name]));
    const update = (filtered) => {
      if (!isEqual(filtered, prop2.value)) {
        prop2.value = filtered;
      }
      if (!isEqual(filtered, props[name])) {
        emit(`update:${name}`, filtered);
      }
    };
    watch(() => filter(prop2.value), update);
    watch(() => props[name], (v) => update(filter(v)));
    if (prop2.value !== props[name]) {
      emit(`update:${name}`, prop2.value);
    }
    return prop2;
  }
  const prop = ref(props[name]);
  watch(() => props[name], (v) => {
    if (!isEqual(v, prop.value)) {
      prop.value = v;
    }
  });
  watch(prop, (v) => {
    if (!isEqual(v, props[name])) {
      emit(`update:${name}`, v);
    }
  });
  return prop;
}
function bindPropKeySet(props, name, sourceObject, emit) {
  const bound = reactive(/* @__PURE__ */ new Set());
  watch(() => props[name], () => {
    const prop = props[name];
    const filtered = prop.filter((n) => n in sourceObject.value);
    if (!isEqual(filtered, Array.from(bound))) {
      bound.clear();
      filtered.forEach(bound.add, bound);
    }
  }, { deep: true, immediate: true });
  watch(bound, () => {
    const array = Array.from(bound);
    if (!isEqual(props[name], array)) {
      emit(`update:${name}`, array);
    }
  });
  return Reactive(bound);
}
function translateFromDomToSvgCoordinates(svg, viewport, coordinates) {
  var _a;
  const point = svg.createSVGPoint();
  point.x = coordinates.x;
  point.y = coordinates.y;
  const svgPoint = point.matrixTransform((_a = viewport.getCTM()) == null ? void 0 : _a.inverse());
  return { x: svgPoint.x, y: svgPoint.y };
}
function translateFromSvgToDomCoordinates(svg, viewport, coordinates) {
  const point = svg.createSVGPoint();
  point.x = coordinates.x;
  point.y = coordinates.y;
  const domPoint = point.matrixTransform(viewport.getCTM());
  return { x: domPoint.x, y: domPoint.y };
}
const _hoisted_1$d = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"];
const _hoisted_2$3 = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"];
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  props: {
    baseX: {
      type: Number,
      default: 0
    },
    baseY: {
      type: Number,
      default: 0
    },
    config: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const x = ref(props.baseX);
    const y = ref(props.baseY);
    const strokeWidth = ref(0);
    const strokeColor = ref("#000000");
    const strokeDasharray = ref(void 0);
    const radius = ref(0);
    const width = ref(0);
    const height = ref(0);
    const borderRadius = ref(0);
    watchEffect(() => {
      var _a;
      const s = scale.value;
      strokeWidth.value = props.config.strokeWidth * s;
      strokeColor.value = (_a = props.config.strokeColor) != null ? _a : "none";
      strokeDasharray.value = applyScaleToDasharray(props.config.strokeDasharray, s);
      if (props.config.type === "circle") {
        x.value = props.baseX;
        y.value = props.baseY;
        radius.value = props.config.radius * s;
      } else {
        width.value = props.config.width * s;
        height.value = props.config.height * s;
        borderRadius.value = props.config.borderRadius * s;
        x.value = props.baseX - width.value / 2;
        y.value = props.baseY - height.value / 2;
      }
    });
    expose({
      x,
      y,
      strokeWidth,
      strokeColor,
      strokeDasharray,
      radius,
      width,
      height,
      borderRadius
    });
    return (_ctx, _cache) => {
      return __props.config.type === "circle" ? (openBlock(), createElementBlock("circle", {
        key: 0,
        class: "v-shape-circle",
        cx: x.value,
        cy: y.value,
        r: radius.value,
        fill: __props.config.color,
        stroke: strokeColor.value,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": strokeDasharray.value
      }, null, 8, _hoisted_1$d)) : (openBlock(), createElementBlock("rect", {
        key: 1,
        class: "v-shape-rect",
        x: x.value,
        y: y.value,
        width: width.value,
        height: height.value,
        rx: borderRadius.value,
        ry: borderRadius.value,
        fill: __props.config.color,
        stroke: strokeColor.value,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": strokeDasharray.value
      }, null, 8, _hoisted_2$3));
    };
  }
});
const _hoisted_1$c = ["rx", "ry", "fill", "transform"];
const _hoisted_2$2 = ["x", "y", "dominant-baseline", "font-family", "font-size", "fill"];
const _hoisted_3$2 = ["x", "dy", "dominant-baseline"];
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  props: {
    text: {
      type: String,
      required: true
    },
    x: {
      type: Number,
      required: true
    },
    y: {
      type: Number,
      required: true
    },
    dominantBaseline: {
      type: String,
      required: false,
      default: "central"
    },
    config: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    function updateBackgroundPosition(element2, pos2, transform2) {
      var _a;
      const bbox = element2.getBBox();
      pos2.x = bbox.x;
      pos2.y = bbox.y;
      pos2.width = bbox.width;
      pos2.height = bbox.height;
      transform2.value = (_a = element2.getAttribute("transform")) != null ? _a : void 0;
    }
    function enableMutationObserver(element2, pos2, transform2) {
      const observer2 = new MutationObserver(() => {
        updateBackgroundPosition(element2, pos2, transform2);
      });
      observer2.observe(element2, {
        attributes: true,
        attributeFilter: ["x", "y", "transform", "font-size"]
      });
      updateBackgroundPosition(element2, pos2, transform2);
      return observer2;
    }
    const attrs = useAttrs();
    const { scale } = useZoomLevel();
    const texts = computed(() => {
      var _a, _b;
      return (_b = (_a = props.text) == null ? void 0 : _a.toString().split(/\r?\n/)) != null ? _b : "";
    });
    const fontSize = computed(() => {
      var _a;
      return (_a = attrs["font-size"]) != null ? _a : props.config.fontSize * scale.value;
    });
    const lineHeight = computed(() => fontSize.value * props.config.lineHeight);
    const topDeltaY = computed(() => {
      const dominantBaseline = props.dominantBaseline;
      if (dominantBaseline === "hanging") {
        return 0;
      } else if (dominantBaseline === "central") {
        return -(lineHeight.value * (texts.value.length - 1)) / 2;
      } else {
        return -lineHeight.value * (texts.value.length - 1);
      }
    });
    const element = ref();
    const transform = ref("");
    const pos = reactive({ x: 0, y: 0, width: 0, height: 0 });
    const backgroundRectPos = computed(() => {
      var _a, _b;
      const config = props.config.background;
      if (!config)
        return pos;
      let paddingVertical, paddingHorizontal;
      if (config.padding instanceof Object) {
        paddingVertical = config.padding.vertical;
        paddingHorizontal = config.padding.horizontal;
      } else {
        paddingVertical = (_a = config.padding) != null ? _a : 0;
        paddingHorizontal = (_b = config.padding) != null ? _b : 0;
      }
      const lineMargin = lineHeight.value - fontSize.value;
      return {
        x: pos.x - paddingHorizontal * scale.value,
        y: pos.y - paddingVertical * scale.value - lineMargin / 2,
        width: pos.width + paddingHorizontal * 2 * scale.value,
        height: pos.height + paddingVertical * 2 * scale.value + lineMargin
      };
    });
    let observer;
    const updateObserver = () => {
      if (props.config.background && props.config.background.visible) {
        if (!observer && element.value) {
          observer = enableMutationObserver(element.value, pos, transform);
        }
      } else {
        observer == null ? void 0 : observer.disconnect();
        observer = void 0;
      }
    };
    onMounted(() => updateObserver());
    watch(() => props.config.background && props.config.background.visible, (v, prev) => {
      if (v == prev)
        return;
      updateObserver();
    });
    onUnmounted(() => {
      observer == null ? void 0 : observer.disconnect();
      observer = void 0;
    });
    expose({ fontSize, element, transform, backgroundRectPos, scale });
    return (_ctx, _cache) => {
      var _a, _b, _c, _d, _e, _f;
      return openBlock(), createElementBlock(Fragment, null, [
        __props.config.background && __props.config.background.visible ? (openBlock(), createElementBlock("rect", mergeProps({
          key: 0,
          class: "v-text-background"
        }, unref(backgroundRectPos), {
          rx: ((_b = (_a = __props.config.background) == null ? void 0 : _a.borderRadius) != null ? _b : 0) * unref(scale),
          ry: ((_d = (_c = __props.config.background) == null ? void 0 : _c.borderRadius) != null ? _d : 0) * unref(scale),
          fill: (_f = (_e = __props.config.background) == null ? void 0 : _e.color) != null ? _f : "#ffffff",
          transform: transform.value
        }), null, 16, _hoisted_1$c)) : createCommentVNode("", true),
        createElementVNode("text", mergeProps({
          ref_key: "element",
          ref: element,
          class: "v-text"
        }, _ctx.$attrs, {
          x: __props.x,
          y: __props.y,
          "dominant-baseline": __props.dominantBaseline,
          "font-family": _ctx.$attrs["font-family"] ? `${_ctx.$attrs["font-family"]}` : __props.config.fontFamily,
          "font-size": unref(fontSize),
          fill: _ctx.$attrs.fill ? `${_ctx.$attrs.fill}` : __props.config.color
        }), [
          unref(texts).length <= 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(__props.text), 1)
          ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(texts), (t, i) => {
            return openBlock(), createElementBlock("tspan", {
              key: i,
              x: __props.x,
              dy: i == 0 ? unref(topDeltaY) : unref(lineHeight),
              "dominant-baseline": __props.dominantBaseline
            }, toDisplayString(t), 9, _hoisted_3$2);
          }), 128))
        ], 16, _hoisted_2$2)
      ], 64);
    };
  }
});
var VNode_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => "[data-v-13e63a9b]:where(.v-shape-circle){pointer-events:none;transition:fill .1s linear,stroke .1s linear,stroke-width .1s linear,r .1s linear}[data-v-13e63a9b]:where(.v-shape-rect){pointer-events:none;transition:fill .1s linear,stroke .1s linear,stroke-width .1s linear,x .1s linear,y .1s linear,width .1s linear,height .1s linear}.v-node[data-v-13e63a9b] .draggable,.v-node[data-v-13e63a9b] .selectable{pointer-events:all;cursor:pointer}.v-node[data-v-13e63a9b] .v-text{pointer-events:none;user-select:none;cursor:default}.v-node[data-v-13e63a9b] :where(.v-text){transition:x .1s linear,y .1s linear}\n")();
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$b = ["transform"];
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    pos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const x = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.x) || 0;
    });
    const y = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.y) || 0;
    });
    const config = useNodeConfig();
    const { scale } = useZoomLevel();
    const {
      handleNodePointerDownEvent,
      handleNodePointerOverEvent,
      handleNodePointerOutEvent,
      handleNodeClickEvent,
      handleNodeDoubleClickEvent,
      handleNodeContextMenu
    } = useMouseOperation();
    const labelVisibility = computed(() => {
      var _a;
      if (props.state.label.visible) {
        return (_a = props.state.labelText) != null ? _a : false;
      }
      return false;
    });
    const labelMargin = computed(() => {
      if (props.state.label.direction === NodeLabelDirection.CENTER) {
        return 0;
      } else {
        return props.state.label.margin * scale.value;
      }
    });
    const labelShiftV = ref(0);
    const labelShiftH = ref(0);
    const labelDiagonalShiftV = ref(0);
    const labelDiagonalShiftH = ref(0);
    watchEffect(() => {
      const s = scale.value;
      const shape = props.state.shape;
      if (shape.type == "circle") {
        const radius = shape.radius * s;
        const m = radius + labelMargin.value;
        const diagonalMargin = Math.sqrt(__pow(m, 2) / 2);
        labelShiftV.value = radius + labelMargin.value;
        labelShiftH.value = radius + labelMargin.value;
        labelDiagonalShiftV.value = diagonalMargin;
        labelDiagonalShiftH.value = diagonalMargin;
      } else {
        const borderRadius = shape.borderRadius * s;
        const width = shape.width * s;
        const height = shape.height * s;
        const m = borderRadius + labelMargin.value;
        const diagonalMargin = Math.sqrt(__pow(m, 2) / 2);
        labelShiftV.value = height / 2 + labelMargin.value;
        labelShiftH.value = width / 2 + labelMargin.value;
        labelDiagonalShiftV.value = height / 2 - borderRadius + diagonalMargin;
        labelDiagonalShiftH.value = width / 2 - borderRadius + diagonalMargin;
      }
    });
    const textAnchor = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.NORTH:
        case NodeLabelDirection.SOUTH:
          return "middle";
        case NodeLabelDirection.EAST:
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.SOUTH_EAST:
          return "start";
        case NodeLabelDirection.WEST:
        case NodeLabelDirection.NORTH_WEST:
        case NodeLabelDirection.SOUTH_WEST:
        default:
          return "end";
      }
    });
    const dominantBaseline = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.NORTH:
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.NORTH_WEST:
          return "text-top";
        case NodeLabelDirection.SOUTH:
        case NodeLabelDirection.SOUTH_EAST:
        case NodeLabelDirection.SOUTH_WEST:
          return "hanging";
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.EAST:
        case NodeLabelDirection.WEST:
        default:
          return "central";
      }
    });
    const labelX = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.NORTH:
        case NodeLabelDirection.SOUTH:
          return 0;
        case NodeLabelDirection.EAST:
          return labelShiftH.value;
        case NodeLabelDirection.WEST:
          return -labelShiftH.value;
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.SOUTH_EAST:
          return labelDiagonalShiftH.value;
        case NodeLabelDirection.NORTH_WEST:
        case NodeLabelDirection.SOUTH_WEST:
        default:
          return -labelDiagonalShiftH.value;
      }
    });
    const labelY = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.NORTH:
          return -labelShiftV.value;
        case NodeLabelDirection.SOUTH:
          return labelShiftV.value;
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.EAST:
        case NodeLabelDirection.WEST:
          return 0;
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.NORTH_WEST:
          return -labelDiagonalShiftV.value;
        case NodeLabelDirection.SOUTH_EAST:
        case NodeLabelDirection.SOUTH_WEST:
        default:
          return labelDiagonalShiftV.value;
      }
    });
    expose({
      x,
      y,
      config,
      labelVisibility,
      handleNodePointerDownEvent,
      handleNodePointerOverEvent,
      handleNodePointerOutEvent,
      handleNodeClickEvent,
      handleNodeDoubleClickEvent,
      handleNodeContextMenu,
      textAnchor,
      dominantBaseline,
      labelX,
      labelY,
      scale
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", {
        class: normalizeClass({ "v-node": true, hover: __props.state.hovered, selected: __props.state.selected }),
        transform: `translate(${unref(x)} ${unref(y)})`,
        onPointerdown: _cache[0] || (_cache[0] = withModifiers(($event) => unref(handleNodePointerDownEvent)(__props.id, $event), ["stop"])),
        onPointerenterPassive: _cache[1] || (_cache[1] = ($event) => unref(handleNodePointerOverEvent)(__props.id, $event)),
        onPointerleavePassive: _cache[2] || (_cache[2] = ($event) => unref(handleNodePointerOutEvent)(__props.id, $event)),
        onClick: _cache[3] || (_cache[3] = withModifiers(($event) => unref(handleNodeClickEvent)(__props.id, $event), ["stop"])),
        onDblclick: _cache[4] || (_cache[4] = withModifiers(($event) => unref(handleNodeDoubleClickEvent)(__props.id, $event), ["stop"])),
        onContextmenu: _cache[5] || (_cache[5] = ($event) => unref(handleNodeContextMenu)(__props.id, $event))
      }, [
        renderSlot(_ctx.$slots, "override-node", {
          nodeId: __props.id,
          scale: unref(scale),
          config: __props.state.shape,
          class: normalizeClass({ draggable: __props.state.draggable, selectable: __props.state.selectable })
        }, () => [
          createVNode(_sfc_main$l, {
            config: __props.state.shape,
            class: normalizeClass({ draggable: __props.state.draggable, selectable: __props.state.selectable })
          }, null, 8, ["config", "class"])
        ], true),
        unref(labelVisibility) ? renderSlot(_ctx.$slots, "override-node-label", {
          key: 0,
          nodeId: __props.id,
          scale: unref(scale),
          text: __props.state.labelText,
          x: unref(labelX),
          y: unref(labelY),
          config: __props.state.label,
          shape: __props.state.shape,
          textAnchor: unref(textAnchor),
          dominantBaseline: unref(dominantBaseline)
        }, () => [
          createVNode(_sfc_main$k, {
            text: __props.state.labelText,
            x: unref(labelX),
            y: unref(labelY),
            config: __props.state.label,
            "text-anchor": unref(textAnchor),
            "dominant-baseline": unref(dominantBaseline)
          }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline"])
        ], true) : createCommentVNode("", true)
      ], 42, _hoisted_1$b);
    };
  }
});
var VNode = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-13e63a9b"]]);
var VNodeFocusRing_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-node-focus-ring[data-v-dbfca3b6]{pointer-events:none}[data-v-dbfca3b6]:where(.v-shape-circle){transition:r .1s linear}[data-v-dbfca3b6]:where(.v-shape-rect){transition:x .1s linear,y .1s linear,width .1s linear,height .1s linear}[data-v-dbfca3b6]:where(.dragging .v-shape-circleg),[data-v-dbfca3b6]:where(.dragging .v-shape-rect){transition:none}\n")();
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    pos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const x = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.x) || 0;
    });
    const y = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.y) || 0;
    });
    const config = useNodeConfig();
    const shapeConfig = reactive({});
    watchEffect(() => {
      var _a, _b, _c;
      const shapeStyle = props.state.shape;
      if (shapeStyle.type === "circle") {
        const shape = {
          type: "circle",
          radius: shapeStyle.radius + ((_a = shapeStyle.strokeWidth) != null ? _a : 0) / 2 + config.focusring.padding + config.focusring.width / 2,
          color: "none",
          strokeWidth: config.focusring.width,
          strokeColor: config.focusring.color,
          strokeDasharray: config.focusring.dasharray
        };
        Object.assign(shapeConfig, shape);
      } else {
        const shape = {
          type: "rect",
          width: shapeStyle.width + ((_b = shapeStyle.strokeWidth) != null ? _b : 0) + config.focusring.padding * 2 + config.focusring.width,
          height: shapeStyle.height + ((_c = shapeStyle.strokeWidth) != null ? _c : 0) + config.focusring.padding * 2 + config.focusring.width,
          borderRadius: shapeStyle.borderRadius > 0 ? shapeStyle.borderRadius + config.focusring.padding : 0,
          color: "none",
          strokeWidth: config.focusring.width,
          strokeColor: config.focusring.color,
          strokeDasharray: config.focusring.dasharray
        };
        Object.assign(shapeConfig, shape);
      }
    });
    expose({ x, y, shapeConfig });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$l, {
        class: "v-node-focus-ring",
        "base-x": unref(x),
        "base-y": unref(y),
        config: unref(shapeConfig)
      }, null, 8, ["base-x", "base-y", "config"]);
    };
  }
});
var VNodeFocusRing = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-dbfca3b6"]]);
var VLine_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-line.animate[data-v-80a2ecac]{--animation-speed: 100;animation:dash-80a2ecac 10s linear infinite;stroke-dashoffset:var(--animation-speed)}@keyframes dash-80a2ecac{to{stroke-dashoffset:0}}\n")();
const _hoisted_1$a = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"];
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  props: {
    p1: {
      type: Object,
      required: true
    },
    p2: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const strokeWidth = computed(() => {
      return props.config.width * scale.value;
    });
    const strokeDasharray = computed(() => {
      return applyScaleToDasharray(props.config.dasharray, scale.value);
    });
    const animationSpeed = computed(() => {
      const speed = props.config.animate ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value : false;
      return speed ? `--animation-speed:${speed}` : void 0;
    });
    expose({ strokeWidth, strokeDasharray, animationSpeed });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-line": true, animate: __props.config.animate }),
        d: `M ${__props.p1.x} ${__props.p1.y} L ${__props.p2.x} ${__props.p2.y}`,
        stroke: __props.config.color,
        "stroke-width": unref(strokeWidth),
        "stroke-dasharray": unref(strokeDasharray),
        "stroke-linecap": __props.config.linecap,
        style: normalizeStyle(unref(animationSpeed))
      }, null, 14, _hoisted_1$a);
    };
  }
});
var VLine = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-80a2ecac"]]);
function baseSlice(array, start, end) {
  var index = -1, length2 = array.length;
  if (start < 0) {
    start = -start > length2 ? 0 : length2 + start;
  }
  end = end > length2 ? length2 : end;
  if (end < 0) {
    end += length2;
  }
  length2 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length2);
  while (++index < length2) {
    result[index] = array[index + start];
  }
  return result;
}
var nativeCeil = Math.ceil, nativeMax = Math.max;
function chunk(array, size, guard) {
  if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }
  var length2 = array == null ? 0 : array.length;
  if (!length2 || size < 1) {
    return [];
  }
  var index = 0, resIndex = 0, result = Array(nativeCeil(length2 / size));
  while (index < length2) {
    result[resIndex++] = baseSlice(array, index, index += size);
  }
  return result;
}
var VEdgeCurved_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-line.animate[data-v-1a7165f7]{--animation-speed: 100;animation:dash-1a7165f7 10s linear infinite;stroke-dashoffset:var(--animation-speed)}@keyframes dash-1a7165f7{to{stroke-dashoffset:0}}\n")();
const _hoisted_1$9 = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"];
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  props: {
    state: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    markerStart: {
      type: String,
      required: false,
      default: void 0
    },
    markerEnd: {
      type: String,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const pathD = computed(() => {
      var _a, _b;
      const p = props.state.position;
      const points = [...(_b = (_a = props.state.curve) == null ? void 0 : _a.control) != null ? _b : [], { x: p.p2.x, y: p.p2.y }];
      const d = [];
      d.push(`M ${p.p1.x} ${p.p1.y}`);
      chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));
      return d.join(" ");
    });
    const strokeWidth = computed(() => {
      return props.config.width * scale.value;
    });
    const strokeDasharray = computed(() => {
      return applyScaleToDasharray(props.config.dasharray, scale.value);
    });
    const animationSpeed = computed(() => {
      const speed = props.config.animate ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value : false;
      return speed ? `--animation-speed:${speed}` : void 0;
    });
    expose({ strokeWidth, strokeDasharray, animationSpeed });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-line": true, animate: __props.config.animate }),
        d: unref(pathD),
        fill: "none",
        stroke: __props.config.color,
        "stroke-width": unref(strokeWidth),
        "stroke-dasharray": unref(strokeDasharray),
        "stroke-linecap": __props.config.linecap,
        style: normalizeStyle(unref(animationSpeed)),
        "marker-start": __props.markerStart,
        "marker-end": __props.markerEnd
      }, null, 14, _hoisted_1$9);
    };
  }
});
var VEdgeCurved = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-1a7165f7"]]);
var VEdge_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => "[data-v-681298a2]:where(.v-line){transition:stroke .1s linear,stroke-width .1s linear;pointer-events:none}\n")();
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    sourcePos: {
      type: Object,
      required: false,
      default: void 0
    },
    targetPos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const config = useEdgeConfig();
    expose({ config });
    return (_ctx, _cache) => {
      return unref(config).type == "straight" || !__props.state.curve ? (openBlock(), createBlock(VLine, mergeProps({ key: 0 }, __props.state.position, {
        class: { selectable: __props.state.selectable, hover: __props.state.hovered, selected: __props.state.selected },
        config: __props.state.line.stroke,
        "marker-start": __props.state.sourceMarkerId ? `url('#${__props.state.sourceMarkerId}')` : void 0,
        "marker-end": __props.state.targetMarkerId ? `url('#${__props.state.targetMarkerId}')` : void 0
      }), null, 16, ["class", "config", "marker-start", "marker-end"])) : (openBlock(), createBlock(VEdgeCurved, {
        key: 1,
        class: normalizeClass({ selectable: __props.state.selectable, hover: __props.state.hovered, selected: __props.state.selected }),
        state: __props.state,
        config: __props.state.line.stroke,
        "marker-start": __props.state.sourceMarkerId ? `url('#${__props.state.sourceMarkerId}')` : void 0,
        "marker-end": __props.state.targetMarkerId ? `url('#${__props.state.targetMarkerId}')` : void 0
      }, null, 8, ["class", "state", "config", "marker-start", "marker-end"]));
    };
  }
});
var VEdge = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-681298a2"]]);
var VEdgeSummarized_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-line-summarized.selectable[data-v-69e96db7]{cursor:pointer}\n")();
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  props: {
    edges: {
      type: Object,
      required: true
    },
    layouts: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const config = useEdgeConfig();
    const {
      handleEdgesPointerDownEvent,
      handleEdgesPointerOverEvent,
      handleEdgesPointerOutEvent,
      handleEdgesClickEvent,
      handleEdgesDoubleClickEvent,
      handleEdgesContextMenu
    } = useMouseOperation();
    const { edgeStates } = useStates();
    const pos = ref({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } });
    const centerPos = ref({ x: 0, y: 0 });
    watchEffect(() => {
      const edgeId = Object.keys(props.edges).find((edgeId2) => edgeId2 in edgeStates);
      if (edgeId) {
        pos.value = edgeStates[edgeId].position;
        centerPos.value = {
          x: (pos.value.p1.x + pos.value.p2.x) / 2,
          y: (pos.value.p1.y + pos.value.p2.y) / 2
        };
      }
    });
    const edgeIds = computed(() => Object.keys(props.edges));
    const labelConfig = computed(() => Config.values(config.summarized.label, props.edges));
    const shapeConfig = computed(() => Config.values(config.summarized.shape, props.edges));
    const strokeConfig = computed(() => Config.values(config.summarized.stroke, props.edges));
    const hovered = computed(() => edgeIds.value.some((edge) => edgeStates[edge].hovered));
    const selectable = computed(() => edgeIds.value.some((edge) => edgeStates[edge].selectable));
    const selected = computed(() => edgeIds.value.some((edge) => edgeStates[edge].selected));
    expose({
      config,
      pos,
      centerPos,
      handleEdgesPointerDownEvent,
      handleEdgesPointerOverEvent,
      handleEdgesPointerOutEvent,
      handleEdgesClickEvent,
      handleEdgesDoubleClickEvent,
      handleEdgesContextMenu,
      hovered,
      selectable,
      selected
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", {
        class: normalizeClass({ "v-line-summarized": true, hovered: unref(hovered), selectable: unref(selectable), selected: unref(selected) }),
        onPointerdown: _cache[0] || (_cache[0] = withModifiers(($event) => unref(handleEdgesPointerDownEvent)(unref(edgeIds), $event), ["stop"])),
        onPointerenterPassive: _cache[1] || (_cache[1] = ($event) => unref(handleEdgesPointerOverEvent)(unref(edgeIds), $event)),
        onPointerleavePassive: _cache[2] || (_cache[2] = ($event) => unref(handleEdgesPointerOutEvent)(unref(edgeIds), $event)),
        onClick: _cache[3] || (_cache[3] = withModifiers(($event) => unref(handleEdgesClickEvent)(unref(edgeIds), $event), ["stop"])),
        onDblclick: _cache[4] || (_cache[4] = withModifiers(($event) => unref(handleEdgesDoubleClickEvent)(unref(edgeIds), $event), ["stop"])),
        onContextmenu: _cache[5] || (_cache[5] = ($event) => unref(handleEdgesContextMenu)(unref(edgeIds), $event))
      }, [
        createVNode(VLine, mergeProps(pos.value, { config: unref(strokeConfig) }), null, 16, ["config"]),
        createVNode(_sfc_main$l, {
          "base-x": centerPos.value.x,
          "base-y": centerPos.value.y,
          config: unref(shapeConfig)
        }, null, 8, ["base-x", "base-y", "config"]),
        createVNode(_sfc_main$k, {
          text: Object.keys(__props.edges).length.toString(),
          x: centerPos.value.x,
          y: centerPos.value.y,
          config: unref(labelConfig),
          "text-anchor": "middle",
          "dominant-baseline": "central"
        }, null, 8, ["text", "x", "y", "config"])
      ], 34);
    };
  }
});
var VEdgeSummarized = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-69e96db7"]]);
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { edgeStates, edgeZOrderedList, edgeGroupStates, layouts } = useStates();
    expose({ edgeStates, edgeZOrderedList, edgeGroupStates, layouts });
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeZOrderedList), (entry) => {
        return openBlock(), createElementBlock(Fragment, null, [
          unref(isSummarizedEdges)(entry) ? (openBlock(), createBlock(VEdgeSummarized, {
            key: entry.key,
            edges: entry.group.edges,
            layouts: unref(layouts).nodes
          }, null, 8, ["edges", "layouts"])) : (openBlock(), createBlock(VEdge, {
            key: entry.key,
            id: entry.key,
            state: unref(edgeStates)[entry.key],
            "source-pos": unref(layouts).nodes[entry.edge.source],
            "target-pos": unref(layouts).nodes[entry.edge.target]
          }, null, 8, ["id", "state", "source-pos", "target-pos"]))
        ], 64);
      }), 256);
    };
  }
});
var VEdgeBackground_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-line-background.selectable[data-v-8dc141be]{cursor:pointer}\n")();
const _hoisted_1$8 = ["d", "stroke-width"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    sourcePos: {
      type: Object,
      required: false,
      default: void 0
    },
    targetPos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const config = useEdgeConfig();
    const {
      handleEdgePointerDownEvent,
      handleEdgePointerOverEvent,
      handleEdgePointerOutEvent,
      handleEdgeClickEvent,
      handleEdgeDoubleClickEvent,
      handleEdgeContextMenu
    } = useMouseOperation();
    const pathD = computed(() => {
      const p = props.state.position;
      if (config.type === "straight" || !props.state.curve) {
        return `M ${p.p1.x} ${p.p1.y} L ${p.p2.x} ${p.p2.y}`;
      } else {
        const points = [...props.state.curve.control, { x: p.p2.x, y: p.p2.y }];
        const d = [];
        d.push(`M ${p.p1.x} ${p.p1.y}`);
        chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));
        return d.join(" ");
      }
    });
    const strokeWidth = computed(() => (props.state.line.stroke.width + 10) * scale.value);
    expose({
      config,
      handleEdgePointerDownEvent,
      handleEdgePointerOverEvent,
      handleEdgePointerOutEvent,
      handleEdgeClickEvent,
      handleEdgeDoubleClickEvent,
      handleEdgeContextMenu
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-line-background": true, selectable: __props.state.selectable }),
        d: unref(pathD),
        stroke: "transparent",
        "stroke-width": unref(strokeWidth),
        fill: "none",
        onPointerdown: _cache[0] || (_cache[0] = withModifiers(($event) => unref(handleEdgePointerDownEvent)(__props.id, $event), ["stop"])),
        onPointerenterPassive: _cache[1] || (_cache[1] = ($event) => unref(handleEdgePointerOverEvent)(__props.id, $event)),
        onPointerleavePassive: _cache[2] || (_cache[2] = ($event) => unref(handleEdgePointerOutEvent)(__props.id, $event)),
        onClick: _cache[3] || (_cache[3] = withModifiers(($event) => unref(handleEdgeClickEvent)(__props.id, $event), ["stop"])),
        onDblclick: _cache[4] || (_cache[4] = withModifiers(($event) => unref(handleEdgeDoubleClickEvent)(__props.id, $event), ["stop"])),
        onContextmenu: _cache[5] || (_cache[5] = ($event) => unref(handleEdgeContextMenu)(__props.id, $event))
      }, null, 42, _hoisted_1$8);
    };
  }
});
var VEdgeBackground = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-8dc141be"]]);
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { edgeStates, edgeGroupStates, layouts } = useStates();
    expose({ edgeStates, edgeGroupStates, layouts });
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroupStates).edgeGroups, ({ summarize, edges }) => {
        return openBlock(), createElementBlock(Fragment, null, [
          !summarize ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(edges, (edge, id) => {
            return openBlock(), createBlock(VEdgeBackground, {
              key: id,
              id,
              state: unref(edgeStates)[id],
              "source-pos": unref(layouts).nodes[edge.source],
              "target-pos": unref(layouts).nodes[edge.target]
            }, null, 8, ["id", "state", "source-pos", "target-pos"]);
          }), 128)) : createCommentVNode("", true)
        ], 64);
      }), 256);
    };
  }
});
var VEdgeLabels_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-edge-labels[data-v-61f68d23] .v-text,.v-edge-labels[data-v-61f68d23] .v-text-background{pointer-events:none}\n")();
const _hoisted_1$7 = { class: "v-edge-labels" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const edgeConfig = useEdgeConfig();
    const { nodeStates, edgeStates, edgeGroupStates, summarizedEdgeStates, layouts } = useStates();
    const { scale } = useZoomLevel();
    const indivisualEdgeGroups = computed(() => Object.fromEntries(Object.entries(edgeGroupStates.edgeGroups).filter(([_, group]) => !group.summarize && Object.keys(group.edges).length > 0)));
    const edgeGroups = computed(() => {
      const indivisual = {};
      const summarized = {};
      Object.entries(edgeGroupStates.edgeGroups).forEach(([id, group]) => {
        if (Object.keys(group.edges).length > 0) {
          if (group.summarize) {
            summarized[id] = group;
          } else {
            indivisual[id] = group;
          }
        }
      });
      return { indivisual, summarized };
    });
    const nodeShape = computed(() => (node) => {
      var _a;
      return {
        pos: (_a = layouts.nodes[node]) != null ? _a : { x: 0, y: 0 },
        shape: nodeStates[node].shape
      };
    });
    const labelAreaPosition = computed(() => (edgeId, source, target, edgeStyle) => {
      return calculateEdgeLabelArea(edgeStates[edgeId].labelPosition, edgeStyle, edgeConfig.label.margin, edgeConfig.label.padding, scale.value);
    });
    const groupLabelAreaPosition = computed(() => (id, group) => {
      var _a, _b;
      const edgeId = Object.keys(group.edges)[0];
      return calculateEdgeLabelArea(edgeStates[edgeId].labelPosition, (_b = (_a = summarizedEdgeStates[id]) == null ? void 0 : _a.stroke) != null ? _b : edgeStates[edgeId].line.stroke, edgeConfig.label.margin, edgeConfig.label.padding, scale.value);
    });
    const representativeEdgeState = computed(() => (group) => {
      return edgeStates[Object.keys(group.edges)[0]];
    });
    expose({
      indivisualEdgeGroups,
      edgeGroups,
      nodeShape,
      labelAreaPosition,
      groupLabelAreaPosition,
      representativeEdgeState,
      edgeStates,
      edgeConfig,
      scale
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", _hoisted_1$7, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroups).indivisual, (group, id) => {
          return openBlock(), createElementBlock(Fragment, { key: id }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(group.edges, (edge, edgeId) => {
              return renderSlot(_ctx.$slots, "edge-label", {
                key: edgeId,
                edgeId,
                edge,
                config: unref(edgeConfig).label,
                area: unref(labelAreaPosition)(edgeId, unref(nodeShape)(edge.source), unref(nodeShape)(edge.target), unref(edgeStates)[edgeId].line.stroke),
                hovered: unref(edgeStates)[edgeId].hovered,
                selected: unref(edgeStates)[edgeId].selected,
                scale: unref(scale)
              }, void 0, true);
            }), 128))
          ], 64);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroups).summarized, (group, id) => {
          return renderSlot(_ctx.$slots, "edges-label", {
            key: id,
            edges: group.edges,
            config: unref(edgeConfig).label,
            area: unref(groupLabelAreaPosition)(id, group),
            hovered: unref(representativeEdgeState)(group).hovered,
            selected: unref(representativeEdgeState)(group).selected,
            scale: unref(scale)
          }, void 0, true);
        }), 128))
      ]);
    };
  }
});
var VEdgeLabels = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-61f68d23"]]);
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { viewport } = useContainers();
    const background = ref();
    const updateAttributes = (attrs, bgLayer, vpLayer) => {
      attrs.forEach((attr) => {
        var _a;
        return bgLayer.setAttribute(attr, (_a = vpLayer.getAttribute(attr)) != null ? _a : "");
      });
    };
    const observer = new MutationObserver((records) => {
      if (!background.value)
        return;
      const attrs = records.map((r) => {
        var _a;
        return (_a = r.attributeName) != null ? _a : "";
      }).filter(Boolean);
      updateAttributes(attrs, background.value, viewport.value);
    });
    onMounted(() => {
      const attrs = ["transform", "style"];
      observer.observe(viewport.value, {
        attributes: true,
        attributeFilter: attrs
      });
      if (!background.value)
        return;
      updateAttributes(attrs, background.value, viewport.value);
    });
    onUnmounted(() => {
      observer.disconnect();
    });
    expose({ background });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", {
        ref_key: "background",
        ref: background,
        class: "v-background-viewport"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 512);
    };
  }
});
var VBackgroundGrid_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".v-background-grid{pointer-events:none}\n")();
const _hoisted_1$6 = {
  class: "v-background-grid",
  "shape-rendering": "crispEdges"
};
const _hoisted_2$1 = ["d"];
const _hoisted_3$1 = ["d"];
const _hoisted_4$1 = ["d"];
const _hoisted_5 = ["d"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { container, svgPanZoom: svgPanZoom2 } = useContainers();
    const { zoomLevel } = useZoomLevel();
    const emitter = useEventEmitter();
    const config = useViewConfig();
    const basePoint = ref({ x: 0, y: 0 });
    const viewport = ref({ width: 500, height: 500 });
    onMounted(() => {
      var _a;
      const pan = (_a = svgPanZoom2.value) == null ? void 0 : _a.getPan();
      if (pan) {
        basePoint.value = {
          x: -pan.x,
          y: -pan.y
        };
      }
      const rect = container.value.getBoundingClientRect();
      viewport.value = {
        width: rect.width,
        height: rect.height
      };
    });
    emitter.on("view:resize", (rect) => {
      viewport.value = { width: rect.width, height: rect.height };
    });
    emitter.on("view:pan", (pan) => {
      basePoint.value = { x: -pan.x, y: -pan.y };
    });
    emitter.on("view:zoom", () => {
      var _a;
      const pan = (_a = svgPanZoom2.value) == null ? void 0 : _a.getPan();
      if (pan) {
        basePoint.value = { x: -pan.x, y: -pan.y };
      }
    });
    const thickVerticals = ref([]);
    const thickHorizontals = ref([]);
    const normalVerticals = ref([]);
    const normalHorizontals = ref([]);
    watchEffect(() => {
      const thickH = [];
      const thickV = [];
      const normalH = [];
      const normalV = [];
      const s = 1 / zoomLevel.value;
      const gi = config.grid.interval;
      const x = basePoint.value.x * s;
      const y = basePoint.value.y * s;
      const width = Math.floor(viewport.value.width / gi + 1) * gi;
      const height = Math.floor(viewport.value.height / gi + 1) * gi;
      const maxWidth = (basePoint.value.x + width) * s;
      const maxHeight = (basePoint.value.y + height) * s;
      const inc = config.grid.thickIncrements;
      const normalDasharray = config.grid.line.dasharray;
      const thickDasharray = config.grid.thick.dasharray;
      let thickAttrs = {
        stroke: config.grid.thick.color,
        "stroke-width": config.grid.thick.width,
        "stroke-dasharray": thickDasharray,
        "stroke-dashoffset": thickDasharray ? x / s : void 0
      };
      let normalAttrs = {
        stroke: config.grid.line.color,
        "stroke-width": config.grid.line.width,
        "stroke-dasharray": normalDasharray,
        "stroke-dashoffset": normalDasharray ? x / s : void 0
      };
      const w = (basePoint.value.x + width) * s;
      for (let i = y; i <= maxHeight; i += gi) {
        const index = Math.floor(i / gi);
        if (inc && index % inc === 0) {
          thickH.push([index, index * gi, x, w, thickAttrs]);
        } else {
          normalH.push([index, index * gi, x, w, normalAttrs]);
        }
      }
      thickAttrs = __spreadValues({}, thickAttrs);
      thickAttrs["stroke-dashoffset"] = thickDasharray ? y / s : void 0;
      normalAttrs = __spreadValues({}, normalAttrs);
      normalAttrs["stroke-dashoffset"] = normalDasharray ? y / s : void 0;
      const h = (basePoint.value.y + height) * s;
      for (let i = x; i <= maxWidth; i += gi) {
        const index = Math.floor(i / gi);
        if (inc && index % inc === 0) {
          thickV.push([index, index * gi, y, h, thickAttrs]);
        } else {
          normalV.push([index, index * gi, y, h, normalAttrs]);
        }
      }
      thickHorizontals.value = thickH;
      thickVerticals.value = thickV;
      normalHorizontals.value = normalH;
      normalVerticals.value = normalV;
    });
    expose({
      thickVerticals,
      thickHorizontals,
      normalVerticals,
      normalHorizontals
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", _hoisted_1$6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(normalHorizontals.value, ([i, v, x, w, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `nv${i}`,
            d: `M ${x} ${v} L ${w} ${v}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_2$1);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(normalVerticals.value, ([i, v, y, h, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `nh${i}`,
            d: `M ${v} ${y} L ${v} ${h}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_3$1);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(thickHorizontals.value, ([i, v, x, w, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `tv${i}`,
            d: `M ${x} ${v} L ${w} ${v}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_4$1);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(thickVerticals.value, ([i, v, y, h, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `th${i}`,
            d: `M ${v} ${y} L ${v} ${h}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_5);
        }), 128))
      ]);
    };
  }
});
function findFirstNonNull(...values) {
  return values.find((v) => !!v);
}
const EPSILON = Number.EPSILON * 100;
function calculatePathPoints(path, nodeStates, nodeLayouts, edgeStates, scale, curveInNode, pathEndType, margin) {
  var _a;
  const edges = path.edges;
  const directions = _detectDirectionsOfPathEdges(edges);
  const edgePos = edges.map((edge, i) => _getEdgeLine(edge, directions[i], edgeStates[edge.edgeId]));
  const points = [];
  let isMarginOverRunStart = false;
  let isMarginOverRunEnd = false;
  {
    const firstEdge = edgePos[0];
    let nodeRadius = _getNodeRadius(nodeStates[firstEdge.source].shape) * scale;
    const lineMargin = margin + (pathEndType === "edgeOfNode" ? nodeRadius : 0);
    const nextPoint = lineMargin <= 0 ? firstEdge.line.source : _calculateEdgeOfNode(firstEdge, lineMargin, nodeLayouts, true);
    points.push(nextPoint);
    nodeRadius = _getNodeRadius(nodeStates[firstEdge.target].shape) * scale;
    if (margin > 0) {
      const distance2 = V.distance(firstEdge.line.source, firstEdge.line.target);
      if (distance2 <= lineMargin + nodeRadius) {
        isMarginOverRunStart = true;
      }
    }
  }
  const length2 = edges.length;
  for (let i = 1; i < length2; i++) {
    const prev = edgePos[i - 1];
    const next = edgePos[i];
    const nodeId = next.source;
    const nodePos = Vector2D.fromObject((_a = nodeLayouts[nodeId]) != null ? _a : { x: 0, y: 0 });
    const crossPoint = _getIntersectionOfLines(prev, next, nodePos);
    const nodeRadius = _getNodeRadius(nodeStates[nodeId].shape) * scale;
    const nodeCoreRadius = Math.max(nodeRadius * (2 / 3), nodeRadius - 4 * scale);
    const prevCoreIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeCoreRadius, true);
    const nextCoreIp = _getIntersectionOfLineAndNode(next, nodePos, nodeCoreRadius, false);
    const prevNodeIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeRadius, true);
    const nextNodeIp = _getIntersectionOfLineAndNode(next, nodePos, nodeRadius, false);
    let pos;
    if (crossPoint) {
      const d = V.distance(crossPoint, nodePos);
      if (d < nodeCoreRadius) {
        pos = [
          findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),
          crossPoint,
          findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source)
        ];
      } else if (d <= nodeRadius) {
        let p1, p2;
        if (prevNodeIp && prevCoreIp) {
          p1 = V.distance(crossPoint, prevCoreIp) < V.distance(crossPoint, prevNodeIp) ? prevCoreIp : prevNodeIp;
        } else {
          p1 = prevNodeIp || prev.line.target;
        }
        if (nextNodeIp && nextCoreIp) {
          p2 = V.distance(crossPoint, nextCoreIp) < V.distance(crossPoint, nextNodeIp) ? nextCoreIp : nextNodeIp;
        } else {
          p2 = nextNodeIp || next.line.source;
        }
        pos = [p1, crossPoint, p2];
      } else {
        if (prevCoreIp && nextCoreIp) {
          pos = [prevCoreIp, nodePos, nextCoreIp];
        } else if (prevNodeIp && nextNodeIp) {
          pos = [prevNodeIp, nodePos, nextNodeIp];
        } else {
          pos = [
            findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),
            nodePos,
            findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source)
          ];
        }
      }
    } else {
      if (prevCoreIp && nextCoreIp) {
        pos = [prevCoreIp, nodePos, nextCoreIp];
      } else if (prevNodeIp && nextNodeIp) {
        pos = [prevNodeIp, nodePos, nextNodeIp];
      } else {
        pos = [prev.line.target, nodePos, next.line.source];
      }
    }
    if (prev.curve) {
      const lastPoints = points[points.length - 1];
      if (lastPoints) {
        const lastPoint = lastPoints instanceof Array ? lastPoints[lastPoints.length - 1] : lastPoints;
        let nextPoint;
        if (pos instanceof Array) {
          nextPoint = curveInNode ? pos[0] : pos[1];
        } else {
          nextPoint = pos;
        }
        const control = calculateBezierCurveControlPoint(lastPoint, prev.curve.circle.center, nextPoint, prev.curve.theta);
        if (pos instanceof Array && curveInNode) {
          points.push([...control, ...pos]);
        } else {
          points.push([...control, nextPoint]);
        }
      }
    } else {
      if (curveInNode || !(pos instanceof Array)) {
        points.push(pos);
      } else {
        if (next.curve) {
          points.push(pos[1]);
        } else {
          points.push(pos[0], pos[2]);
        }
      }
    }
  }
  {
    const lastEdge = edgePos[edgePos.length - 1];
    let nodeRadius = _getNodeRadius(nodeStates[lastEdge.target].shape) * scale;
    const lineMargin = margin + (pathEndType === "edgeOfNode" ? nodeRadius : 0);
    const nextPoint = lineMargin <= 0 ? lastEdge.line.target : _calculateEdgeOfNode(lastEdge, lineMargin, nodeLayouts, false);
    nodeRadius = _getNodeRadius(nodeStates[lastEdge.source].shape) * scale;
    const curve = lastEdge.curve;
    if (curve) {
      const pos = points[points.length - 1];
      const lastPoint = pos instanceof Array ? pos[pos.length - 1] : pos;
      const control = calculateBezierCurveControlPoint(lastPoint, curve.circle.center, nextPoint, curve.theta);
      points.push([...control, nextPoint]);
    } else {
      points.push(nextPoint);
    }
    if (margin > 0) {
      const distance2 = V.distance(lastEdge.line.source, lastEdge.line.target);
      if (distance2 <= lineMargin + nodeRadius) {
        isMarginOverRunEnd = true;
      }
    }
  }
  if (isMarginOverRunStart) {
    points.shift();
    if (points[0] instanceof Array) {
      points.unshift(points[0][0]);
    }
  }
  if (isMarginOverRunEnd) {
    points.pop();
  }
  return points;
}
function _detectDirectionsOfPathEdges(edges) {
  const length2 = edges.length;
  if (length2 <= 1) {
    return [true];
  }
  const directions = [];
  let lastNode = null;
  for (let i = 0; i < length2; i++) {
    const source = edges[i].edge.source;
    const target = edges[i].edge.target;
    let isForward;
    if (i === 0) {
      if (length2 > 2) {
        const edge0 = [source, target].sort();
        const edge1 = [edges[1].edge.source, edges[1].edge.target].sort();
        if (edge0[0] === edge1[0] && edge0[1] === edge1[1]) {
          const next = [edges[2].edge.source, edges[2].edge.target];
          if (next.includes(edges[1].edge.target)) {
            isForward = target === edges[1].edge.source;
          } else {
            isForward = target === edges[1].edge.target;
          }
        } else {
          isForward = [edges[1].edge.source, edges[1].edge.target].includes(target);
        }
      } else {
        isForward = [edges[1].edge.source, edges[1].edge.target].includes(target);
      }
    } else {
      isForward = lastNode === source;
    }
    directions.push(isForward);
    lastNode = isForward ? target : source;
  }
  return directions;
}
function _calculateEdgeOfNode(edge, nodeRadius, nodeLayouts, direction) {
  const nodeId = direction ? edge.source : edge.target;
  const curve = edge.curve;
  if (curve) {
    let moveRad = nodeRadius / curve.circle.radius;
    if (curve.theta > 0) {
      moveRad *= -1;
    }
    if (!direction) {
      moveRad *= -1;
    }
    return Vector2D.fromObject(moveOnCircumference(direction ? edge.line.source : edge.line.target, curve.circle.center, moveRad));
  } else {
    let source, target;
    if (direction) {
      source = edge.line.target;
      target = edge.line.source;
    } else {
      source = edge.line.source;
      target = edge.line.target;
    }
    const p = getIntersectionOfLineTargetAndCircle(source, target, Vector2D.fromObject(nodeLayouts[nodeId]), nodeRadius);
    return p === null ? source : p;
  }
}
function _getIntersectionOfLines(prev, next, nodePos) {
  let crossPoint = null;
  if (prev.curve) {
    if (next.curve) {
      if (prev.line.target.isEqualTo(next.line.source)) {
        return prev.line.target.clone();
      }
      crossPoint = getIntersectionOfCircles(prev.curve.circle.center, prev.curve.circle.radius, next.curve.circle.center, next.curve.circle.radius, prev.curve.center);
    } else {
      crossPoint = getIntersectionOfLineTargetAndCircle2(next.line.target, next.line.source, prev.curve.circle.center, prev.curve.circle.radius, nodePos);
    }
  } else {
    if (next.curve) {
      crossPoint = getIntersectionOfLineTargetAndCircle(prev.line.source, prev.line.target, next.curve.circle.center, next.curve.circle.radius);
    } else {
      const prevSlope = _getSlope(prev.line);
      const nextSlope = _getSlope(next.line);
      const isParallel = !isFinite(prevSlope) && !isFinite(nextSlope) || Math.abs(prevSlope - nextSlope) < EPSILON;
      if (isParallel) {
        crossPoint = null;
      } else {
        crossPoint = getIntersectionPointOfLines(prev.line, next.line);
      }
    }
  }
  return crossPoint;
}
function _getIntersectionOfLineAndNode(edge, nodeCenter, nodeRadius, targetSide) {
  if (edge.curve) {
    return getIntersectionOfCircles(nodeCenter, nodeRadius, edge.curve.circle.center, edge.curve.circle.radius, Vector2D.fromObject(edge.curve.center));
  } else {
    return getIntersectionOfLineTargetAndCircle(targetSide ? edge.line.source : edge.line.target, targetSide ? edge.line.target : edge.line.source, nodeCenter, nodeRadius);
  }
}
function _getEdgeLine(edge, direction, state) {
  let position = state.origin;
  let source = edge.edge.source;
  let target = edge.edge.target;
  let curve = state.curve;
  if (!direction) {
    position = inverseLine(position);
    source = edge.edge.target;
    target = edge.edge.source;
    if (curve) {
      curve = __spreadProps(__spreadValues({}, curve), { theta: -curve.theta });
    }
  }
  const line = VectorLine.fromLinePosition(position);
  const result = {
    edgeId: edge.edgeId,
    source,
    target,
    line,
    curve
  };
  return result;
}
function _getNodeRadius(shape) {
  if (shape.type == "circle") {
    return shape.radius;
  } else {
    return Math.min(shape.width, shape.height) / 2;
  }
}
function _getSlope(pos) {
  return (pos.target.y - pos.source.y) / (pos.target.x - pos.source.x);
}
var VPathLine_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-path-line.animate[data-v-e0c8fe90]{--animation-speed: 100;animation:dash-e0c8fe90 10s linear infinite;stroke-dashoffset:var(--animation-speed)}@keyframes dash-e0c8fe90{to{stroke-dashoffset:0}}\n")();
const _hoisted_1$5 = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  props: {
    points: {
      type: Array,
      required: true
    },
    path: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const pathConfig = usePathConfig();
    const d = computed(() => {
      let move = true;
      return props.points.map((p) => {
        if (p === null) {
          move = true;
        } else if (p instanceof Array) {
          p = [...p];
          const list = [];
          if (p.length % 2 === 1) {
            const x = p[0];
            p = p.slice(1);
            list.push(`L ${x.x} ${x.y}`);
          }
          chunk(p, 2).map(([p1, p2]) => list.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));
          return list.join(" ");
        } else {
          const m = move;
          move = false;
          return `${m ? "M " : "L "}${p.x} ${p.y}`;
        }
      }).join(" ");
    });
    const config = computed(() => {
      const state = props.path;
      if (state.selected) {
        return Config.values(pathConfig.selected, state.path);
      } else if (state.hovered && pathConfig.hover) {
        return Config.values(pathConfig.hover, state.path);
      } else {
        return Config.values(pathConfig.normal, state.path);
      }
    });
    const strokeDasharray = computed(() => {
      return applyScaleToDasharray(config.value.dasharray, scale.value);
    });
    const animationSpeed = computed(() => {
      const speed = config.value.animate ? getDasharrayUnit(config.value.dasharray) * config.value.animationSpeed * scale.value : false;
      return speed ? `--animation-speed:${speed}` : void 0;
    });
    expose({ d, scale, config, strokeDasharray, animationSpeed });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-path-line": true, animate: unref(config).animate }),
        d: unref(d),
        fill: "none",
        stroke: unref(config).color,
        "stroke-width": unref(config).width * unref(scale),
        "stroke-dasharray": unref(strokeDasharray),
        "stroke-linecap": unref(config).linecap,
        "stroke-linejoin": unref(config).linejoin,
        style: normalizeStyle(unref(animationSpeed))
      }, null, 14, _hoisted_1$5);
    };
  }
});
var VPathLine = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-e0c8fe90"]]);
var VPaths_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-path-line[data-v-5ef199da]{pointer-events:none;transition:stroke .1s linear,stroke-width .1s linear}.v-path-line.clickable[data-v-5ef199da]{pointer-events:stroke;cursor:pointer}.v-path-line.hoverable[data-v-5ef199da]{pointer-events:stroke}\n")();
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { pathZOrderedList, nodeStates, edgeStates, layouts } = useStates();
    const { scale } = useZoomLevel();
    const pathConfig = usePathConfig();
    const {
      handlePathPointerDownEvent,
      handlePathPointerOverEvent,
      handlePathPointerOutEvent,
      handlePathClickEvent,
      handlePathDoubleClickEvent,
      handlePathContextMenu
    } = useMouseOperation();
    const calcPathPoints = computed(() => (path) => {
      if (path.edges.length === 0)
        return [];
      const margin = Config.value(pathConfig.margin, path.path) * scale.value;
      return calculatePathPoints(path, nodeStates, layouts.nodes, edgeStates, scale.value, pathConfig.curveInNode, pathConfig.end, margin);
    });
    expose({
      pathConfig,
      pathZOrderedList,
      calcPathPoints,
      handlePathPointerDownEvent,
      handlePathPointerOverEvent,
      handlePathPointerOutEvent,
      handlePathClickEvent,
      handlePathDoubleClickEvent,
      handlePathContextMenu
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(TransitionGroup, {
        name: unref(pathConfig).transition,
        css: !!unref(pathConfig).transition,
        tag: "g",
        class: "v-paths"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pathZOrderedList), (path) => {
            return openBlock(), createBlock(VPathLine, {
              key: path.id,
              points: unref(calcPathPoints)(path),
              class: normalizeClass({ clickable: path.clickable, hoverable: path.hoverable }),
              path,
              onPointerdown: ($event) => unref(handlePathPointerDownEvent)(path.id, $event),
              onPointerenterPassive: ($event) => unref(handlePathPointerOverEvent)(path.id, $event),
              onPointerleavePassive: ($event) => unref(handlePathPointerOutEvent)(path.id, $event),
              onClick: withModifiers(($event) => unref(handlePathClickEvent)(path.id, $event), ["stop"]),
              onDblclick: withModifiers(($event) => unref(handlePathDoubleClickEvent)(path.id, $event), ["stop"]),
              onContextmenu: ($event) => unref(handlePathContextMenu)(path.id, $event)
            }, null, 8, ["points", "class", "path", "onPointerdown", "onPointerenterPassive", "onPointerleavePassive", "onClick", "onDblclick", "onContextmenu"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["name", "css"]);
    };
  }
});
var VPaths = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-5ef199da"]]);
const _hoisted_1$4 = ["points", "fill"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  props: {
    width: {
      type: Number,
      required: true
    },
    height: {
      type: Number,
      required: true
    },
    refX: {
      type: Number,
      required: true
    },
    color: {
      type: String,
      required: true
    },
    isSource: {
      type: Boolean,
      required: true
    },
    units: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const arrowPoints = computed(() => {
      const w = props.width;
      const h = props.height;
      if (props.isSource) {
        return `${w} ${h}, 0 ${h / 2}, ${w} 0`;
      } else {
        return `0 0, ${w} ${h / 2}, 0 ${h}`;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("polygon", {
        points: unref(arrowPoints),
        fill: __props.color
      }, null, 8, _hoisted_1$4);
    };
  }
});
const _hoisted_1$3 = ["points", "stroke-width", "stroke"];
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  props: {
    width: {
      type: Number,
      required: true
    },
    height: {
      type: Number,
      required: true
    },
    refX: {
      type: Number,
      required: true
    },
    color: {
      type: String,
      required: true
    },
    isSource: {
      type: Boolean,
      required: true
    },
    units: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const angleStroke = computed(() => {
      return props.units === "strokeWidth" ? 1 : Math.min(props.width, props.height) / 5;
    });
    const anglePoints = computed(() => {
      const m = angleStroke.value / 2;
      const w = props.width;
      const h = props.height;
      if (props.isSource) {
        return `${w - m} ${h - m}, ${m} ${h / 2}, ${w - m} ${m}`;
      } else {
        return `${m} ${m}, ${w - m} ${h / 2}, ${m} ${h - m}`;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("polyline", {
        points: unref(anglePoints),
        fill: "none",
        "stroke-width": unref(angleStroke),
        stroke: __props.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      }, null, 8, _hoisted_1$3);
    };
  }
});
const _hoisted_1$2 = ["fill", "cx", "cy", "rx", "ry"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  props: {
    width: {
      type: Number,
      required: true
    },
    height: {
      type: Number,
      required: true
    },
    refX: {
      type: Number,
      required: true
    },
    color: {
      type: String,
      required: true
    },
    isSource: {
      type: Boolean,
      required: true
    },
    units: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("ellipse", {
        fill: __props.color,
        cx: __props.width / 2,
        cy: __props.height / 2,
        rx: __props.width / 2,
        ry: __props.height / 2
      }, null, 8, _hoisted_1$2);
    };
  }
});
const _hoisted_1$1 = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    marker: {
      type: Object,
      required: true
    },
    scale: {
      type: Number,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const types = {
      arrow: _sfc_main$5,
      angle: _sfc_main$4,
      circle: _sfc_main$3
    };
    const width = computed(() => props.marker.width * (props.marker.units === "strokeWidth" ? 1 : props.scale));
    const height = computed(() => props.marker.height * (props.marker.units === "strokeWidth" ? 1 : props.scale));
    const refX = computed(() => {
      const margin = props.marker.margin * (props.marker.units === "strokeWidth" ? 1 : props.scale);
      return props.marker.isSource ? width.value + margin : -margin;
    });
    return (_ctx, _cache) => {
      return __props.marker.type !== "none" && __props.marker.type !== "custom" ? (openBlock(), createElementBlock("marker", {
        key: 0,
        id: __props.id,
        markerWidth: unref(width),
        markerHeight: unref(height),
        refX: unref(refX),
        refY: unref(height) / 2,
        orient: "auto",
        markerUnits: __props.marker.units,
        class: "v-marker"
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(types[__props.marker.type]), {
          width: unref(width),
          height: unref(height),
          refX: unref(refX),
          color: __props.marker.color,
          "is-source": __props.marker.isSource,
          units: __props.marker.units
        }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
      ], 8, _hoisted_1$1)) : createCommentVNode("", true);
    };
  }
});
var VNetworkGraph_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => ".v-network-graph[data-v-844b9d08]{padding:0;position:relative;user-select:none}[data-v-844b9d08]:where(.v-network-graph){width:100%;height:100%}.v-canvas[data-v-844b9d08]{-webkit-tap-highlight-color:transparent;width:100%;height:100%;opacity:0}.v-canvas.show[data-v-844b9d08]{opacity:1;transition:opacity .5s linear}.v-canvas.dragging[data-v-844b9d08] *{cursor:grabbing!important}.v-canvas.dragging[data-v-844b9d08] .v-line{transition:d 0s}.v-canvas.touches[data-v-844b9d08]{touch-action:none}.v-canvas[data-v-844b9d08]{--transition-duration: .3s;--transition-function: linear}.v-canvas .v-viewport.v-transition[data-v-844b9d08] .v-node{transition:transform var(--transition-duration) var(--transition-function)}.v-canvas .v-viewport.v-transition[data-v-844b9d08] .v-layer-edges path{transition:d var(--transition-duration) var(--transition-function)}.v-canvas .v-viewport.v-transition[data-v-844b9d08] .v-path-line{transition:d var(--transition-duration) var(--transition-function)}\n")();
const SYSTEM_SLOTS = ["override-node", "override-node-label", "edge-label", "edges-label"];
const _sfc_main$1 = defineComponent({
  components: {
    VNode,
    VNodeFocusRing,
    VEdgeGroups: _sfc_main$d,
    VEdgeBackgrounds: _sfc_main$b,
    VEdgeLabels,
    VBackgroundViewport: _sfc_main$9,
    VBackgroundGrid: _sfc_main$8,
    VPaths,
    VMarkerHead: _sfc_main$2
  },
  props: {
    nodes: {
      type: Object,
      default: () => ({})
    },
    edges: {
      type: Object,
      default: () => ({})
    },
    paths: {
      type: [Object, Array],
      default: () => ({})
    },
    layouts: {
      type: Object,
      default: () => ({})
    },
    zoomLevel: {
      type: Number,
      default: 1
    },
    selectedNodes: {
      type: Array,
      default: () => []
    },
    selectedEdges: {
      type: Array,
      default: () => []
    },
    selectedPaths: {
      type: Array,
      default: () => []
    },
    configs: {
      type: Object,
      default: () => ({})
    },
    layers: {
      type: Object,
      default: () => ({})
    },
    eventHandlers: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [
    "update:zoomLevel",
    "update:selectedNodes",
    "update:selectedEdges",
    "update:selectedPaths",
    "update:layouts"
  ],
  setup(props, { emit, slots }) {
    const nodesRef = toRef(props, "nodes");
    const edgesRef = toRef(props, "edges");
    const { objects: pathsRef, isInCompatibilityModeForPath } = useTranslatePathsToObject(toRef(props, "paths"));
    const emitter = provideEventEmitter();
    Object.entries(props.eventHandlers).forEach(([type, event]) => {
      emitter.on(type, event);
    });
    const configs = provideConfigs(toRef(props, "configs"));
    const layerDefs = computed(() => {
      const definedSlots = new Set(Object.keys(slots));
      SYSTEM_SLOTS.forEach((s) => definedSlots.delete(s));
      const layers = Object.fromEntries(LayerPositions.map((n) => [n, []]));
      Object.assign(layers, Object.entries(props.layers).reduce((accum, [name, type]) => {
        definedSlots.delete(name);
        if (type in accum) {
          accum[type].push(name);
        } else {
          accum[type] = [name];
        }
        return accum;
      }, {}));
      layers["root"].push(...definedSlots);
      return layers;
    });
    const isShowGrid = computed(() => configs.view.grid.visible);
    const isShowBackgroundViewport = computed(() => {
      const layers = layerDefs.value;
      return isShowGrid.value || layers["background"].length > 0 || layers["grid"].length > 0;
    });
    const overrideNodes = computed(() => "override-node" in slots);
    const overrideNodeLabels = computed(() => "override-node-label" in slots);
    const overrideEdgeLabels = computed(() => "edge-label" in slots);
    const overrideEdgesLabels = computed(() => "edges-label" in slots);
    const container = ref();
    const svg = ref();
    const viewport = ref();
    const state = ref(0);
    const show = computed(() => state.value !== 0);
    const zoomLevel = bindProp(props, "zoomLevel", emit, (v) => {
      v = Math.max(v, configs.view.minZoomLevel);
      v = Math.min(v, configs.view.maxZoomLevel);
      return v;
    });
    const { svgPanZoom: svgPanZoom2, onSvgPanZoomMounted, onSvgPanZoomUnmounted } = useSvgPanZoom(svg, {
      viewportSelector: ".v-viewport",
      minZoom: configs.view.minZoomLevel,
      maxZoom: configs.view.maxZoomLevel,
      dblClickZoomEnabled: isDoubleClickZoomEnabled(configs.view),
      mouseWheelZoomEnabled: isMouseWheelZoomEnabled(configs.view),
      fit: true,
      center: true,
      zoomEnabled: configs.view.zoomEnabled,
      preventMouseEventsDefault: false,
      onZoom: (_) => {
        var _a, _b;
        if (state.value === 2)
          return;
        const z = (_b = (_a = svgPanZoom2.value) == null ? void 0 : _a.getRealZoom()) != null ? _b : 1;
        if (Math.abs(zoomLevel.value - z) >= 1e-6) {
          zoomLevel.value = z;
          emitter.emit("view:zoom", z);
        }
      },
      panEnabled: configs.view.panEnabled,
      onPan: (p) => {
        if (state.value === 2)
          return;
        emitter.emit("view:pan", p);
      }
    });
    provideContainers({ container, svg, viewport, svgPanZoom: svgPanZoom2 });
    const rectSize = { width: 0, height: 0 };
    const resizeObserver = globalThis.ResizeObserver ? new ResizeObserver(() => {
      var _a, _b, _c;
      (_a = svgPanZoom2.value) == null ? void 0 : _a.resize();
      if (!configs.view.autoPanOnResize)
        return;
      const r = (_b = container.value) == null ? void 0 : _b.getBoundingClientRect();
      if (r) {
        const x = -(rectSize.width - r.width) / 2;
        const y = -(rectSize.height - r.height) / 2;
        (_c = svgPanZoom2.value) == null ? void 0 : _c.panBy({ x, y });
        const { width, height } = r;
        if (rectSize.width !== width || rectSize.height !== height) {
          Object.assign(rectSize, { width, height });
          emitter.emit("view:resize", { x: r.x, y: r.y, width, height });
        }
      }
    }) : void 0;
    onSvgPanZoomMounted(() => {
      var _a, _b, _c;
      const c = nonNull(container.value, "svg-pan-zoom container");
      resizeObserver == null ? void 0 : resizeObserver.observe(c);
      (_b = (_a = configs.view).onSvgPanZoomInitialized) == null ? void 0 : _b.call(_a, nonNull(svgPanZoom2.value, "svg-pan-zoom instance"));
      const r = c.getBoundingClientRect();
      const { width, height } = r;
      Object.assign(rectSize, { width, height });
      (_c = viewport.value) == null ? void 0 : _c.addEventListener("touchstart", stopEventPropagation, { passive: false });
    });
    onSvgPanZoomUnmounted(() => {
      var _a;
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      (_a = viewport.value) == null ? void 0 : _a.removeEventListener("touchstart", stopEventPropagation);
    });
    const applyAbsoluteZoomLevel = (absoluteZoomLevel) => {
      var _a;
      (_a = svgPanZoom2.value) == null ? void 0 : _a.applyAbsoluteZoomLevel(absoluteZoomLevel, configs.view.minZoomLevel, configs.view.maxZoomLevel);
    };
    watch(() => configs.view.panEnabled, (v) => {
      var _a;
      (_a = svgPanZoom2.value) == null ? void 0 : _a.setPanEnabled(v);
    });
    watch(() => [
      configs.view.zoomEnabled,
      isDoubleClickZoomEnabled(configs.view),
      isMouseWheelZoomEnabled(configs.view)
    ], (v) => {
      applyZoomEnabled(svgPanZoom2.value, configs.view.zoomEnabled, configs.view.doubleClickZoomEnabled, configs.view.mouseWheelZoomEnabled);
    });
    watch(zoomLevel, (v) => applyAbsoluteZoomLevel(v));
    watch(() => [configs.view.minZoomLevel, configs.view.maxZoomLevel], (_) => {
      applyAbsoluteZoomLevel(zoomLevel.value);
    });
    const { scale } = provideZoomLevel(zoomLevel, configs.view);
    onSvgPanZoomMounted(() => {
      const initialZoomLevel = props.zoomLevel;
      applyAbsoluteZoomLevel(initialZoomLevel);
    });
    const updateBorderBox = (callback) => {
      var _a;
      if (Object.keys(props.nodes).length > 0) {
        (_a = svgPanZoom2.value) == null ? void 0 : _a.updateBBox();
        nextTick(callback);
      } else {
        callback();
      }
    };
    const fitToContents = () => {
      updateBorderBox(() => {
        if (svgPanZoom2.value) {
          svgPanZoom2.value.fitToContents();
          emitter.emit("view:fit", void 0);
        }
      });
    };
    const panToCenter = () => {
      updateBorderBox(() => {
        var _a;
        (_a = svgPanZoom2.value) == null ? void 0 : _a.center();
      });
    };
    const getViewBox = () => {
      var _a, _b;
      return (_b = (_a = svgPanZoom2.value) == null ? void 0 : _a.getViewBox()) != null ? _b : {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    };
    const setViewBox = (box) => {
      var _a;
      return (_a = svgPanZoom2.value) == null ? void 0 : _a.setViewBox(box);
    };
    const currentSelectedNodes = bindPropKeySet(props, "selectedNodes", nodesRef, emit);
    watch(currentSelectedNodes, (nodes) => emitter.emit("node:select", Array.from(nodes)));
    const currentSelectedEdges = bindPropKeySet(props, "selectedEdges", edgesRef, emit);
    watch(currentSelectedEdges, (edges) => emitter.emit("edge:select", Array.from(edges)));
    const currentSelectedPaths = bindPropKeySet(props, "selectedPaths", pathsRef, emit);
    watch(currentSelectedPaths, (paths) => emitter.emit("path:select", Array.from(paths)));
    const hoveredNodes = Reactive(/* @__PURE__ */ new Set());
    const hoveredEdges = Reactive(/* @__PURE__ */ new Set());
    const hoveredPaths = Reactive(/* @__PURE__ */ new Set());
    const currentLayouts = Reactive({ nodes: {} });
    watch(() => props.layouts, () => Object.assign(currentLayouts, props.layouts), { deep: true, immediate: true });
    watch(currentLayouts, () => emit("update:layouts", currentLayouts), { deep: true });
    const visibleNodeFocusRing = computed(() => {
      return configs.node.focusring.visible;
    });
    const markerState = makeMarkerState();
    const dragging = ref(false);
    emitter.on("node:dragstart", (_) => dragging.value = true);
    emitter.on("node:dragend", (_) => dragging.value = false);
    emitter.on("view:mode", (mode) => {
      var _a, _b, _c, _d;
      if (configs.view.panEnabled) {
        if (mode === "default") {
          (_a = svgPanZoom2.value) == null ? void 0 : _a.enablePan();
        } else {
          (_b = svgPanZoom2.value) == null ? void 0 : _b.disablePan();
        }
      }
      if (configs.view.zoomEnabled) {
        if (mode === "default") {
          (_c = svgPanZoom2.value) == null ? void 0 : _c.enableZoom();
        } else {
          (_d = svgPanZoom2.value) == null ? void 0 : _d.disableZoom();
        }
      }
    });
    const touches = computed(() => {
      return configs.view.panEnabled || configs.view.zoomEnabled || configs.node.draggable;
    });
    const { nodeStates, nodeZOrderedList, edgeStates, pathStates } = provideStates(makeStateInput(nodesRef, currentSelectedNodes, hoveredNodes), makeStateInput(edgesRef, currentSelectedEdges, hoveredEdges), makeStateInput(pathsRef, currentSelectedPaths, hoveredPaths), readonly(configs), currentLayouts, markerState, scale);
    const isSvgWheelZoomEnabled = computed(() => isMouseWheelZoomEnabled(configs.view));
    provideMouseOperation(svg, readonly(currentLayouts.nodes), readonly(zoomLevel), nodeStates, edgeStates, pathStates, currentSelectedNodes, currentSelectedEdges, currentSelectedPaths, hoveredNodes, hoveredEdges, hoveredPaths, isInCompatibilityModeForPath, isSvgWheelZoomEnabled, emitter);
    const visiblePaths = computed(() => configs.path.visible);
    const activateParams = () => ({
      layouts: Reactive(currentLayouts.nodes),
      nodes: nodesRef,
      edges: edgesRef,
      configs: readonly(configs),
      scale: readonly(scale),
      emitter,
      svgPanZoom: nonNull(svgPanZoom2.value)
    });
    watch(() => configs.view.layoutHandler, (newHandler, oldHandler) => {
      oldHandler.deactivate();
      newHandler.activate(activateParams());
    });
    const { transitionWhile, transitionOption } = useTransitionWhile();
    const transitionStyles = computed(() => {
      const o = transitionOption.value;
      return o.enabled ? {
        "--transition-duration": o.duration + "ms",
        "--transition-function": o.timingFunction
      } : {};
    });
    onSvgPanZoomMounted(() => {
      updateBorderBox(() => {
        const svg2 = nonNull(svgPanZoom2.value, "svg-pan-zoom");
        configs.view.layoutHandler.activate(activateParams());
        nextTick(() => {
          const autoPanAndZoom = configs.view.autoPanAndZoomOnLoad;
          if (configs.view.fit || autoPanAndZoom !== false) {
            const nodesEmpty = Object.keys(props.nodes).length == 0;
            if (nodesEmpty || autoPanAndZoom === "center-zero") {
              const sizes = svg2.getSizes();
              svg2.pan({
                x: sizes.width / 2,
                y: sizes.height / 2
              });
            } else if (autoPanAndZoom === "fit-content" || configs.view.fit) {
              fitToContents();
            } else if (autoPanAndZoom === "center-content") {
              panToCenter();
            }
          }
          emitter.emit("view:load");
          state.value = 1;
        });
      });
    });
    onSvgPanZoomUnmounted(() => {
      state.value = 2;
      emitter.emit("view:unload");
      configs.view.layoutHandler.deactivate();
    });
    return {
      container,
      svg,
      viewport,
      show,
      svgPanZoom: svgPanZoom2,
      allConfigs: configs,
      layerDefs,
      isShowGrid,
      isShowBackgroundViewport,
      overrideNodes,
      overrideNodeLabels,
      overrideEdgeLabels,
      overrideEdgesLabels,
      scale,
      nodeStates,
      nodeZOrderedList,
      currentSelectedNodes,
      markers: markerState.markers,
      dragging,
      touches,
      currentLayouts,
      visibleNodeFocusRing,
      visiblePaths,
      transitionOption,
      transitionStyles,
      fitToContents,
      panToCenter,
      getViewBox,
      setViewBox,
      transitionWhile
    };
  },
  methods: {
    zoomIn() {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.zoomIn();
    },
    zoomOut() {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.zoomOut();
    },
    panTo(point) {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.pan(point);
    },
    panBy(point) {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.panBy(point);
    },
    getPan() {
      return nonNull(this.svgPanZoom).getPan();
    },
    getSizes() {
      const sizes = nonNull(this.svgPanZoom).getSizes();
      return {
        width: sizes.width,
        height: sizes.height,
        viewBox: sizes.viewBox
      };
    },
    translateFromDomToSvgCoordinates(coordinates) {
      return translateFromDomToSvgCoordinates(nonNull(this.svg, "svg"), nonNull(this.viewport, "viewport"), coordinates);
    },
    translateFromSvgToDomCoordinates(coordinates) {
      return translateFromSvgToDomCoordinates(nonNull(this.svg, "svg"), nonNull(this.viewport, "viewport"), coordinates);
    },
    getAsSvg() {
      const element = nonNull(this.svg, "svg");
      const viewport = nonNull(this.viewport, "svg viewport");
      const target = element.cloneNode(true);
      const box = viewport.getBBox();
      const z = 1 / this.scale;
      const svg = {
        x: Math.floor((box.x - 10) * z),
        y: Math.floor((box.y - 10) * z),
        width: Math.ceil((box.width + 20) * z),
        height: Math.ceil((box.height + 20) * z)
      };
      target.setAttribute("width", svg.width.toString());
      target.setAttribute("height", svg.height.toString());
      const v = target.querySelector(".v-viewport");
      v.setAttribute("transform", `translate(${-svg.x} ${-svg.y}), scale(${z})`);
      v.removeAttribute("style");
      target.setAttribute("viewBox", `0 0 ${svg.width} ${svg.height}`);
      let data = target.outerHTML;
      data = data.replaceAll(/ data-v-[0-9a-z]+=""/g, "");
      data = data.replaceAll(/<!--[\s\S]*?-->/gm, "");
      return data;
    }
  }
});
function applyZoomEnabled(svgPanZoom2, enable, enableDblClick, enableMouseWheel) {
  svgPanZoom2.setZoomEnabled(enable);
  if (enable && enableDblClick) {
    svgPanZoom2.enableDblClickZoom();
  } else {
    svgPanZoom2.disableDblClickZoom();
  }
  if (enable && enableMouseWheel) {
    svgPanZoom2.enableMouseWheelZoom();
  } else {
    svgPanZoom2.disableMouseWheelZoom();
  }
}
function isDoubleClickZoomEnabled(view) {
  return view.zoomEnabled && view.doubleClickZoomEnabled;
}
function isMouseWheelZoomEnabled(view) {
  return view.zoomEnabled && view.mouseWheelZoomEnabled;
}
function stopEventPropagation(event) {
  event.stopPropagation();
}
const _hoisted_1 = {
  ref: "container",
  class: "v-network-graph"
};
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { class: "v-layer-edges" };
const _hoisted_4 = {
  key: 2,
  class: "v-layer-nodes-selections"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_v_marker_head = resolveComponent("v-marker-head");
  const _component_v_background_grid = resolveComponent("v-background-grid");
  const _component_v_background_viewport = resolveComponent("v-background-viewport");
  const _component_v_edge_backgrounds = resolveComponent("v-edge-backgrounds");
  const _component_v_edge_groups = resolveComponent("v-edge-groups");
  const _component_v_edge_labels = resolveComponent("v-edge-labels");
  const _component_v_node_focus_ring = resolveComponent("v-node-focus-ring");
  const _component_v_node = resolveComponent("v-node");
  const _component_v_paths = resolveComponent("v-paths");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    (openBlock(), createElementBlock("svg", {
      ref: "svg",
      class: normalizeClass(["v-canvas", { show: _ctx.show, dragging: _ctx.dragging, touches: _ctx.touches }]),
      width: "500",
      height: "500",
      viewBox: "0 0 500 500"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["root"], (layerName) => {
        return renderSlot(_ctx.$slots, layerName, {
          key: layerName,
          scale: _ctx.scale
        }, void 0, true);
      }), 128)),
      Object.keys(_ctx.markers).length > 0 ? (openBlock(), createElementBlock("defs", _hoisted_2, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.markers, (marker, id) => {
          return openBlock(), createBlock(_component_v_marker_head, {
            id,
            key: id,
            marker,
            scale: _ctx.scale
          }, null, 8, ["id", "marker", "scale"]);
        }), 128))
      ])) : createCommentVNode("", true),
      _ctx.isShowBackgroundViewport ? (openBlock(), createBlock(_component_v_background_viewport, { key: 1 }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["background"], (layerName) => {
            return openBlock(), createElementBlock("g", {
              key: layerName,
              class: "v-layer"
            }, [
              renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
            ]);
          }), 128)),
          _ctx.isShowGrid ? (openBlock(), createBlock(_component_v_background_grid, { key: 0 })) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["grid"], (layerName) => {
            return openBlock(), createElementBlock("g", {
              key: layerName,
              class: "v-layer"
            }, [
              renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
            ]);
          }), 128))
        ]),
        _: 3
      })) : createCommentVNode("", true),
      createElementVNode("g", {
        ref: "viewport",
        class: normalizeClass(["v-viewport", { "v-transition": _ctx.transitionOption.enabled }]),
        style: normalizeStyle(_ctx.transitionStyles)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["base"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        createElementVNode("g", _hoisted_3, [
          createVNode(_component_v_edge_backgrounds),
          createVNode(_component_v_edge_groups)
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["edges"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        _ctx.overrideEdgeLabels ? (openBlock(), createBlock(_component_v_edge_labels, { key: 0 }, {
          "edge-label": withCtx((slotProps) => [
            renderSlot(_ctx.$slots, "edge-label", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
          ]),
          _: 3
        })) : createCommentVNode("", true),
        _ctx.overrideEdgesLabels ? (openBlock(), createBlock(_component_v_edge_labels, { key: 1 }, {
          "edges-label": withCtx((slotProps) => [
            renderSlot(_ctx.$slots, "edges-label", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
          ]),
          _: 3
        })) : createCommentVNode("", true),
        _ctx.visibleNodeFocusRing ? (openBlock(), createElementBlock("g", _hoisted_4, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentSelectedNodes, (nodeId) => {
            return openBlock(), createBlock(_component_v_node_focus_ring, {
              id: nodeId,
              key: nodeId,
              state: _ctx.nodeStates[nodeId],
              pos: _ctx.currentLayouts.nodes[nodeId]
            }, null, 8, ["id", "state", "pos"]);
          }), 128))
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["focusring"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        createVNode(TransitionGroup, {
          name: _ctx.allConfigs.node.transition,
          css: !!_ctx.allConfigs.node.transition,
          tag: "g",
          class: "v-layer-nodes"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodeZOrderedList, (state) => {
              return openBlock(), createBlock(_component_v_node, {
                id: state.id,
                key: state.id,
                state,
                pos: _ctx.currentLayouts.nodes[state.id]
              }, createSlots({ _: 2 }, [
                _ctx.overrideNodes ? {
                  name: "override-node",
                  fn: withCtx((slotProps) => [
                    renderSlot(_ctx.$slots, "override-node", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
                  ])
                } : void 0,
                _ctx.overrideNodeLabels ? {
                  name: "override-node-label",
                  fn: withCtx((slotProps) => [
                    renderSlot(_ctx.$slots, "override-node-label", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
                  ])
                } : void 0
              ]), 1032, ["id", "state", "pos"]);
            }), 128))
          ]),
          _: 3
        }, 8, ["name", "css"]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["nodes"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        _ctx.visiblePaths ? (openBlock(), createBlock(_component_v_paths, { key: 3 })) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["paths"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128))
      ], 6)
    ], 2))
  ], 512);
}
var VNetworkGraph = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-844b9d08"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    area: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    text: {
      type: String,
      required: false,
      default: ""
    },
    align: {
      type: String,
      required: false,
      default: "center"
    },
    verticalAlign: {
      type: String,
      required: false,
      default: "center"
    },
    edge: {
      type: Object,
      required: false,
      default: void 0
    },
    hovered: {
      type: Boolean,
      required: false,
      default: false
    },
    selected: {
      type: Boolean,
      required: false,
      default: false
    },
    scale: {
      type: Number,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const x = ref(0);
    const y = ref(0);
    const textAnchor = ref("middle");
    const dominantBaseline = ref("central");
    const angle2 = ref(0);
    watchEffect(() => {
      const s = props.area.source;
      const t = props.area.target;
      if (props.align === "source") {
        if (s.above.x == t.above.x) {
          textAnchor.value = s.above.y > t.above.y ? "start" : "end";
        } else {
          textAnchor.value = s.above.x < t.above.x ? "start" : "end";
        }
        if (props.verticalAlign === "above") {
          x.value = s.above.x;
          y.value = s.above.y;
          dominantBaseline.value = "text-top";
        } else if (props.verticalAlign === "below") {
          x.value = s.below.x;
          y.value = s.below.y;
          dominantBaseline.value = "hanging";
        } else {
          x.value = (s.above.x + s.below.x) / 2;
          y.value = (s.above.y + s.below.y) / 2;
          dominantBaseline.value = "central";
        }
      } else if (props.align === "target") {
        if (s.above.x == t.above.x) {
          textAnchor.value = s.above.y < t.above.y ? "start" : "end";
        } else {
          textAnchor.value = s.above.x > t.above.x ? "start" : "end";
        }
        if (props.verticalAlign === "above") {
          x.value = t.above.x;
          y.value = t.above.y;
          dominantBaseline.value = "text-top";
        } else if (props.verticalAlign === "below") {
          x.value = t.below.x;
          y.value = t.below.y;
          dominantBaseline.value = "hanging";
        } else {
          x.value = (t.above.x + t.below.x) / 2;
          y.value = (t.above.y + t.below.y) / 2;
          dominantBaseline.value = "central";
        }
      } else {
        textAnchor.value = "middle";
        if (props.verticalAlign === "above") {
          x.value = (s.above.x + t.above.x) / 2;
          y.value = (s.above.y + t.above.y) / 2;
          dominantBaseline.value = "text-top";
        } else if (props.verticalAlign === "below") {
          x.value = (s.below.x + t.below.x) / 2;
          y.value = (s.below.y + t.below.y) / 2;
          dominantBaseline.value = "hanging";
        } else {
          x.value = (s.above.x + t.below.x) / 2;
          y.value = (s.above.y + t.below.y) / 2;
          dominantBaseline.value = "central";
        }
      }
      let degree = VectorLine.fromPositions(s.above, t.above).v.angleDegree();
      if (degree < -90 || degree >= 90) {
        degree = degree + 180;
        if (degree > 180) {
          degree -= 360;
        }
      }
      angle2.value = degree;
    });
    const updatedConfig = computed(() => {
      if (dominantBaseline.value === "central" && !props.config.background) {
        return __spreadProps(__spreadValues({}, props.config), {
          background: {
            visible: true,
            color: "#ffffff",
            padding: {
              vertical: 1,
              horizontal: 4
            },
            borderRadius: 2
          }
        });
      } else {
        return props.config;
      }
    });
    expose({ x, y, textAnchor, dominantBaseline, angle: angle2, updatedConfig });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$k, {
        class: "v-edge-label",
        text: __props.text,
        x: x.value,
        y: y.value,
        config: unref(updatedConfig),
        "text-anchor": textAnchor.value,
        "dominant-baseline": dominantBaseline.value,
        transform: `rotate(${angle2.value} ${x.value} ${y.value})`
      }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]);
    };
  }
});
var components = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  VNetworkGraph,
  VShape: _sfc_main$l,
  VEdgeLabel: _sfc_main,
  VLabelText: _sfc_main$k
});
const DEFAULT_GRID = 10;
class GridLayout extends SimpleLayout {
  constructor(options = {}) {
    super();
    this.options = options;
  }
  setNodePosition(nodeLayout, pos) {
    const grid = this.options.grid || DEFAULT_GRID;
    nodeLayout.value.x = Math.floor(pos.x / grid) * grid;
    nodeLayout.value.y = Math.floor(pos.y / grid) * grid;
  }
}
const install = function(app) {
  Object.entries(components).forEach(([componentName, component]) => {
    app.component(componentName, component);
  });
};
export { Config, GridLayout, LayerPositions, NodeLabelDirection, SimpleLayout, _sfc_main as VEdgeLabel, _sfc_main$k as VLabelText, VNetworkGraph, _sfc_main$l as VShape, Vector2D, configsWithType, install as default, defineConfigs, getFullConfigs, useStates, withSelf };
//# sourceMappingURL=index.mjs.map
