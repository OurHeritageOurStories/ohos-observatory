import type { Vector2D } from '../..';
import type { Point2D } from '../../modules/vector2d/core';
import type { NodeStates } from '../../models/node';
import type { DefineComponent, Ref, ComputedRef, WatchStopHandle, ComponentOptionsMixin, EmitsOptions, VNodeProps, AllowedComponentProps, ComponentCustomProps, ExtractPropTypes } from 'vue';
import type { Edge, Layouts, FixablePosition, EdgeLabelArea, Position } from '../../common/types';
import type { EdgeConfig, ShapeStyle, AnyShapeStyle,  StrokeStyle } from '../../common/configs';
import type { EdgeStates, EdgeGroupStates, SummarizedEdgeStates, Line, EdgeGroup } from '../../models/edge';
interface NodeShape {
    pos: Position;
    shape: AnyShapeStyle;
}
declare const _sfc_main: DefineComponent<{}, {
    edgeConfig: EdgeConfig<Edge>;
    nodeStates: NodeStates;
    edgeStates: EdgeStates;
    edgeGroupStates: EdgeGroupStates;
    summarizedEdgeStates: SummarizedEdgeStates;
    layouts: Layouts;
    scale: Ref<number>;
    indivisualEdgeGroups: ComputedRef<{
        [k: string]: EdgeGroup;
    }>;
    edgeGroups: ComputedRef<{
        indivisual: Record<string, EdgeGroup>;
        summarized: Record<string, EdgeGroup>;
    }>;
    nodeShape: ComputedRef<(node: string) => {
        pos: FixablePosition;
        shape: ShapeStyle;
    }>;
    labelAreaPosition: ComputedRef<(edgeId: string, source: NodeShape, target: NodeShape, edgeStyle: StrokeStyle) => EdgeLabelArea>;
    groupLabelAreaPosition: ComputedRef<(id: string, group: EdgeGroup) => EdgeLabelArea>;
    representativeEdgeState: ComputedRef<(group: EdgeGroup) => {
        id: string;
        line: Line;
        selectable: number | boolean;
        selected: boolean;
        hovered: boolean;
        origin: {
            p1: {
                x: number;
                y: number;
            };
            p2: {
                x: number;
                y: number;
            };
        };
        labelPosition: {
            p1: {
                x: number;
                y: number;
            };
            p2: {
                x: number;
                y: number;
            };
        };
        position: {
            p1: {
                x: number;
                y: number;
            };
            p2: {
                x: number;
                y: number;
            };
        };
        curve?: {
            center: {
                x: number;
                y: number;
                add: (v: Point2D) => Vector2D;
                subtract: (v: Point2D) => Vector2D;
                multiply: (v: Point2D) => Vector2D;
                multiplyScalar: (scalar: number) => Vector2D;
                divide: (v: Point2D) => Vector2D;
                dot: (v: Point2D) => number;
                cross: (v: Point2D) => number;
                lengthSquared: () => number;
                length: () => number;
                distanceSquared: (v: Point2D) => number;
                distance: (v: Point2D) => number;
                normalize: () => Vector2D;
                angle: () => number;
                angleDegree: () => number;
                rotate: (angle: number) => Vector2D;
                isEqualTo: (v: Point2D) => boolean;
                clone: () => Vector2D;
                toObject: () => Point2D;
                toArray: () => [number, number];
            };
            theta: number;
            circle: {
                center: {
                    x: number;
                    y: number;
                    add: (v: Point2D) => Vector2D;
                    subtract: (v: Point2D) => Vector2D;
                    multiply: (v: Point2D) => Vector2D;
                    multiplyScalar: (scalar: number) => Vector2D;
                    divide: (v: Point2D) => Vector2D;
                    dot: (v: Point2D) => number;
                    cross: (v: Point2D) => number;
                    lengthSquared: () => number;
                    length: () => number;
                    distanceSquared: (v: Point2D) => number;
                    distance: (v: Point2D) => number;
                    normalize: () => Vector2D;
                    angle: () => number;
                    angleDegree: () => number;
                    rotate: (angle: number) => Vector2D;
                    isEqualTo: (v: Point2D) => boolean;
                    clone: () => Vector2D;
                    toObject: () => Point2D;
                    toArray: () => [number, number];
                };
                radius: number;
            };
            control: {
                x: number;
                y: number;
            }[];
        } | undefined;
        sourceMarkerId?: string | undefined;
        targetMarkerId?: string | undefined;
        zIndex: number;
        stopWatchHandle: WatchStopHandle;
    }>;
}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, EmitsOptions, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
export default _sfc_main;
