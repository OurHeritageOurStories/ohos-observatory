import type { LooseRequired } from '@vue/shared';
import type { Point2D } from '../../modules/vector2d/core';
import type { Layouts, Vector2D, Position, EdgeConfig, Edge, StrokeStyle, Edges, NodePositions, LabelStyle, ShapeStyle, AnyShapeStyle } from '../..';
import type { EdgeStates, EdgeEntry, Line } from '../../models/edge';
import type { DefineComponent, ComputedRef, PropType, WatchStopHandle, ExtractPropTypes, Ref, ComponentOptionsMixin, VNodeProps, AllowedComponentProps, ComponentCustomProps, EmitsOptions } from 'vue';
import type { EdgeGroupStates, isSummarizedEdges } from '../../composables/state';
declare const _sfc_main: DefineComponent<{}, {
    edgeStates: EdgeStates;
    edgeZOrderedList: ComputedRef<EdgeEntry[]>;
    edgeGroupStates: EdgeGroupStates;
    layouts: Layouts;
    isSummarizedEdges: typeof isSummarizedEdges;
    VEdge: DefineComponent<{
        id: {
            type: StringConstructor;
            required: true;
        };
        state: {
            type: PropType<{
                id: string;
                line: Line;
                selectable: number | boolean;
                selected: boolean;
                hovered: boolean;
                origin: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                labelPosition: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                position: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                curve?: {
                    center: {
                        x: number;
                        y: number;
                        add: (v: Point2D) => Vector2D;
                        subtract: (v: Point2D) => Vector2D;
                        multiply: (v: Point2D) => Vector2D;
                        multiplyScalar: (scalar: number) => Vector2D;
                        divide: (v: Point2D) => Vector2D;
                        dot: (v: Point2D) => number;
                        cross: (v: Point2D) => number;
                        lengthSquared: () => number;
                        length: () => number;
                        distanceSquared: (v: Point2D) => number;
                        distance: (v: Point2D) => number;
                        normalize: () => Vector2D;
                        angle: () => number;
                        angleDegree: () => number;
                        rotate: (angle: number) => Vector2D;
                        isEqualTo: (v: Point2D) => boolean;
                        clone: () => Vector2D;
                        toObject: () => Point2D;
                        toArray: () => [number, number];
                    };
                    theta: number;
                    circle: {
                        center: {
                            x: number;
                            y: number;
                            add: (v: Point2D) => Vector2D;
                            subtract: (v: Point2D) => Vector2D;
                            multiply: (v: Point2D) => Vector2D;
                            multiplyScalar: (scalar: number) => Vector2D;
                            divide: (v: Point2D) => Vector2D;
                            dot: (v: Point2D) => number;
                            cross: (v: Point2D) => number;
                            lengthSquared: () => number;
                            length: () => number;
                            distanceSquared: (v: Point2D) => number;
                            distance: (v: Point2D) => number;
                            normalize: () => Vector2D;
                            angle: () => number;
                            angleDegree: () => number;
                            rotate: (angle: number) => Vector2D;
                            isEqualTo: (v: Point2D) => boolean;
                            clone: () => Vector2D;
                            toObject: () => Point2D;
                            toArray: () => [number, number];
                        };
                        radius: number;
                    };
                    control: {
                        x: number;
                        y: number;
                    }[];
                } | undefined;
                sourceMarkerId?: string | undefined;
                targetMarkerId?: string | undefined;
                zIndex: number;
                stopWatchHandle: WatchStopHandle;
            }>;
            required: true;
        };
        sourcePos: {
            type: PropType<Position>;
            required: false;
            default: undefined;
        };
        targetPos: {
            type: PropType<Position>;
            required: false;
            default: undefined;
        };
    }, {
        config: EdgeConfig<Edge>;
        VLine: DefineComponent<{
            p1: {
                type: PropType<Position>;
                required: true;
            };
            p2: {
                type: PropType<Position>;
                required: true;
            };
            config: {
                type: PropType<StrokeStyle>;
                required: true;
            };
        }, {
            props: Readonly<LooseRequired<Readonly<ExtractPropTypes<{
                p1: {
                    type: PropType<Position>;
                    required: true;
                };
                p2: {
                    type: PropType<Position>;
                    required: true;
                };
                config: {
                    type: PropType<StrokeStyle>;
                    required: true;
                };
            }>> & {
                [x: string & `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            scale: Ref<number>;
            strokeWidth: ComputedRef<number>;
            strokeDasharray: ComputedRef<string | number | undefined>;
            animationSpeed: ComputedRef<string | undefined>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            p1: {
                type: PropType<Position>;
                required: true;
            };
            p2: {
                type: PropType<Position>;
                required: true;
            };
            config: {
                type: PropType<StrokeStyle>;
                required: true;
            };
        }>>, {}>;
        VEdgeCurved: DefineComponent<{
            state: {
                type: PropType<{
                    id: string;
                    line: Line;
                    selectable: number | boolean;
                    selected: boolean;
                    hovered: boolean;
                    origin: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    labelPosition: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    position: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    curve?: {
                        center: {
                            x: number;
                            y: number;
                            add: (v: Point2D) => Vector2D;
                            subtract: (v: Point2D) => Vector2D;
                            multiply: (v: Point2D) => Vector2D;
                            multiplyScalar: (scalar: number) => Vector2D;
                            divide: (v: Point2D) => Vector2D;
                            dot: (v: Point2D) => number;
                            cross: (v: Point2D) => number;
                            lengthSquared: () => number;
                            length: () => number;
                            distanceSquared: (v: Point2D) => number;
                            distance: (v: Point2D) => number;
                            normalize: () => Vector2D;
                            angle: () => number;
                            angleDegree: () => number;
                            rotate: (angle: number) => Vector2D;
                            isEqualTo: (v: Point2D) => boolean;
                            clone: () => Vector2D;
                            toObject: () => Point2D;
                            toArray: () => [number, number];
                        };
                        theta: number;
                        circle: {
                            center: {
                                x: number;
                                y: number;
                                add: (v: Point2D) => Vector2D;
                                subtract: (v: Point2D) => Vector2D;
                                multiply: (v: Point2D) => Vector2D;
                                multiplyScalar: (scalar: number) => Vector2D;
                                divide: (v: Point2D) => Vector2D;
                                dot: (v: Point2D) => number;
                                cross: (v: Point2D) => number;
                                lengthSquared: () => number;
                                length: () => number;
                                distanceSquared: (v: Point2D) => number;
                                distance: (v: Point2D) => number;
                                normalize: () => Vector2D;
                                angle: () => number;
                                angleDegree: () => number;
                                rotate: (angle: number) => Vector2D;
                                isEqualTo: (v: Point2D) => boolean;
                                clone: () => Vector2D;
                                toObject: () => Point2D;
                                toArray: () => [number, number];
                            };
                            radius: number;
                        };
                        control: {
                            x: number;
                            y: number;
                        }[];
                    } | undefined;
                    sourceMarkerId?: string | undefined;
                    targetMarkerId?: string | undefined;
                    zIndex: number;
                    stopWatchHandle: WatchStopHandle;
                }>;
                required: true;
            };
            config: {
                type: PropType<StrokeStyle>;
                required: true;
            };
            markerStart: {
                type: StringConstructor;
                required: false;
                default: undefined;
            };
            markerEnd: {
                type: StringConstructor;
                required: false;
                default: undefined;
            };
        }, {
            props: Readonly<LooseRequired<Readonly<ExtractPropTypes<{
                state: {
                    type: PropType<{
                        id: string;
                        line: Line;
                        selectable: number | boolean;
                        selected: boolean;
                        hovered: boolean;
                        origin: {
                            p1: {
                                x: number;
                                y: number;
                            };
                            p2: {
                                x: number;
                                y: number;
                            };
                        };
                        labelPosition: {
                            p1: {
                                x: number;
                                y: number;
                            };
                            p2: {
                                x: number;
                                y: number;
                            };
                        };
                        position: {
                            p1: {
                                x: number;
                                y: number;
                            };
                            p2: {
                                x: number;
                                y: number;
                            };
                        };
                        curve?: {
                            center: {
                                x: number;
                                y: number;
                                add: (v: Point2D) => Vector2D;
                                subtract: (v: Point2D) => Vector2D;
                                multiply: (v: Point2D) => Vector2D;
                                multiplyScalar: (scalar: number) => Vector2D;
                                divide: (v: Point2D) => Vector2D;
                                dot: (v: Point2D) => number;
                                cross: (v: Point2D) => number;
                                lengthSquared: () => number;
                                length: () => number;
                                distanceSquared: (v: Point2D) => number;
                                distance: (v: Point2D) => number;
                                normalize: () => Vector2D;
                                angle: () => number;
                                angleDegree: () => number;
                                rotate: (angle: number) => Vector2D;
                                isEqualTo: (v: Point2D) => boolean;
                                clone: () => Vector2D;
                                toObject: () => Point2D;
                                toArray: () => [number, number];
                            };
                            theta: number;
                            circle: {
                                center: {
                                    x: number;
                                    y: number;
                                    add: (v: Point2D) => Vector2D;
                                    subtract: (v: Point2D) => Vector2D;
                                    multiply: (v: Point2D) => Vector2D;
                                    multiplyScalar: (scalar: number) => Vector2D;
                                    divide: (v: Point2D) => Vector2D;
                                    dot: (v: Point2D) => number;
                                    cross: (v: Point2D) => number;
                                    lengthSquared: () => number;
                                    length: () => number;
                                    distanceSquared: (v: Point2D) => number;
                                    distance: (v: Point2D) => number;
                                    normalize: () => Vector2D;
                                    angle: () => number;
                                    angleDegree: () => number;
                                    rotate: (angle: number) => Vector2D;
                                    isEqualTo: (v: Point2D) => boolean;
                                    clone: () => Vector2D;
                                    toObject: () => Point2D;
                                    toArray: () => [number, number];
                                };
                                radius: number;
                            };
                            control: {
                                x: number;
                                y: number;
                            }[];
                        } | undefined;
                        sourceMarkerId?: string | undefined;
                        targetMarkerId?: string | undefined;
                        zIndex: number;
                        stopWatchHandle: WatchStopHandle;
                    }>;
                    required: true;
                };
                config: {
                    type: PropType<StrokeStyle>;
                    required: true;
                };
                markerStart: {
                    type: StringConstructor;
                    required: false;
                    default: undefined;
                };
                markerEnd: {
                    type: StringConstructor;
                    required: false;
                    default: undefined;
                };
            }>> & {
                [x: string & `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            scale: Ref<number>;
            pathD: ComputedRef<string>;
            strokeWidth: ComputedRef<number>;
            strokeDasharray: ComputedRef<string | number | undefined>;
            animationSpeed: ComputedRef<string | undefined>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            state: {
                type: PropType<{
                    id: string;
                    line: Line;
                    selectable: number | boolean;
                    selected: boolean;
                    hovered: boolean;
                    origin: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    labelPosition: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    position: {
                        p1: {
                            x: number;
                            y: number;
                        };
                        p2: {
                            x: number;
                            y: number;
                        };
                    };
                    curve?: {
                        center: {
                            x: number;
                            y: number;
                            add: (v: Point2D) => Vector2D;
                            subtract: (v: Point2D) => Vector2D;
                            multiply: (v: Point2D) => Vector2D;
                            multiplyScalar: (scalar: number) => Vector2D;
                            divide: (v: Point2D) => Vector2D;
                            dot: (v: Point2D) => number;
                            cross: (v: Point2D) => number;
                            lengthSquared: () => number;
                            length: () => number;
                            distanceSquared: (v: Point2D) => number;
                            distance: (v: Point2D) => number;
                            normalize: () => Vector2D;
                            angle: () => number;
                            angleDegree: () => number;
                            rotate: (angle: number) => Vector2D;
                            isEqualTo: (v: Point2D) => boolean;
                            clone: () => Vector2D;
                            toObject: () => Point2D;
                            toArray: () => [number, number];
                        };
                        theta: number;
                        circle: {
                            center: {
                                x: number;
                                y: number;
                                add: (v: Point2D) => Vector2D;
                                subtract: (v: Point2D) => Vector2D;
                                multiply: (v: Point2D) => Vector2D;
                                multiplyScalar: (scalar: number) => Vector2D;
                                divide: (v: Point2D) => Vector2D;
                                dot: (v: Point2D) => number;
                                cross: (v: Point2D) => number;
                                lengthSquared: () => number;
                                length: () => number;
                                distanceSquared: (v: Point2D) => number;
                                distance: (v: Point2D) => number;
                                normalize: () => Vector2D;
                                angle: () => number;
                                angleDegree: () => number;
                                rotate: (angle: number) => Vector2D;
                                isEqualTo: (v: Point2D) => boolean;
                                clone: () => Vector2D;
                                toObject: () => Point2D;
                                toArray: () => [number, number];
                            };
                            radius: number;
                        };
                        control: {
                            x: number;
                            y: number;
                        }[];
                    } | undefined;
                    sourceMarkerId?: string | undefined;
                    targetMarkerId?: string | undefined;
                    zIndex: number;
                    stopWatchHandle: WatchStopHandle;
                }>;
                required: true;
            };
            config: {
                type: PropType<StrokeStyle>;
                required: true;
            };
            markerStart: {
                type: StringConstructor;
                required: false;
                default: undefined;
            };
            markerEnd: {
                type: StringConstructor;
                required: false;
                default: undefined;
            };
        }>>, {
            markerStart: string;
            markerEnd: string;
        }>;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
        id: {
            type: StringConstructor;
            required: true;
        };
        state: {
            type: PropType<{
                id: string;
                line: Line;
                selectable: number | boolean;
                selected: boolean;
                hovered: boolean;
                origin: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                labelPosition: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                position: {
                    p1: {
                        x: number;
                        y: number;
                    };
                    p2: {
                        x: number;
                        y: number;
                    };
                };
                curve?: {
                    center: {
                        x: number;
                        y: number;
                        add: (v: Point2D) => Vector2D;
                        subtract: (v: Point2D) => Vector2D;
                        multiply: (v: Point2D) => Vector2D;
                        multiplyScalar: (scalar: number) => Vector2D;
                        divide: (v: Point2D) => Vector2D;
                        dot: (v: Point2D) => number;
                        cross: (v: Point2D) => number;
                        lengthSquared: () => number;
                        length: () => number;
                        distanceSquared: (v: Point2D) => number;
                        distance: (v: Point2D) => number;
                        normalize: () => Vector2D;
                        angle: () => number;
                        angleDegree: () => number;
                        rotate: (angle: number) => Vector2D;
                        isEqualTo: (v: Point2D) => boolean;
                        clone: () => Vector2D;
                        toObject: () => Point2D;
                        toArray: () => [number, number];
                    };
                    theta: number;
                    circle: {
                        center: {
                            x: number;
                            y: number;
                            add: (v: Point2D) => Vector2D;
                            subtract: (v: Point2D) => Vector2D;
                            multiply: (v: Point2D) => Vector2D;
                            multiplyScalar: (scalar: number) => Vector2D;
                            divide: (v: Point2D) => Vector2D;
                            dot: (v: Point2D) => number;
                            cross: (v: Point2D) => number;
                            lengthSquared: () => number;
                            length: () => number;
                            distanceSquared: (v: Point2D) => number;
                            distance: (v: Point2D) => number;
                            normalize: () => Vector2D;
                            angle: () => number;
                            angleDegree: () => number;
                            rotate: (angle: number) => Vector2D;
                            isEqualTo: (v: Point2D) => boolean;
                            clone: () => Vector2D;
                            toObject: () => Point2D;
                            toArray: () => [number, number];
                        };
                        radius: number;
                    };
                    control: {
                        x: number;
                        y: number;
                    }[];
                } | undefined;
                sourceMarkerId?: string | undefined;
                targetMarkerId?: string | undefined;
                zIndex: number;
                stopWatchHandle: WatchStopHandle;
            }>;
            required: true;
        };
        sourcePos: {
            type: PropType<Position>;
            required: false;
            default: undefined;
        };
        targetPos: {
            type: PropType<Position>;
            required: false;
            default: undefined;
        };
    }>>, {
        sourcePos: Position;
        targetPos: Position;
    }>;
    VEdgeSummarized: DefineComponent<{
        edges: {
            type: PropType<Edges>;
            required: true;
        };
        layouts: {
            type: PropType<NodePositions>;
            required: true;
        };
    }, {
        props: Readonly<LooseRequired<Readonly<ExtractPropTypes<{
            edges: {
                type: PropType<Edges>;
                required: true;
            };
            layouts: {
                type: PropType<NodePositions>;
                required: true;
            };
        }>> & {
            [x: string & `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
        }>>;
        config: EdgeConfig<Edge>;
        handleEdgesPointerDownEvent: (edges: string[], event: PointerEvent) => void;
        handleEdgesPointerOverEvent: (edges: string[], event: PointerEvent) => void;
        handleEdgesPointerOutEvent: (edges: string[], event: PointerEvent) => void;
        handleEdgesClickEvent: (edges: string[], event: MouseEvent) => void;
        handleEdgesDoubleClickEvent: (edges: string[], event: MouseEvent) => void;
        handleEdgesContextMenu: (edges: string[], event: MouseEvent) => void;
        edgeStates: EdgeStates;
        pos: Ref<{
            p1: {
                x: number;
                y: number;
            };
            p2: {
                x: number;
                y: number;
            };
        }>;
        centerPos: Ref<{
            x: number;
            y: number;
        }>;
        edgeIds: ComputedRef<string[]>;
        labelConfig: ComputedRef<LabelStyle>;
        shapeConfig: ComputedRef<ShapeStyle>;
        strokeConfig: ComputedRef<StrokeStyle>;
        hovered: ComputedRef<boolean>;
        selectable: ComputedRef<boolean>;
        selected: ComputedRef<boolean>;
        VLine: DefineComponent<{
            p1: {
                type: PropType<Position>;
                required: true;
            };
            p2: {
                type: PropType<Position>;
                required: true;
            };
            config: {
                type: PropType<StrokeStyle>;
                required: true;
            };
        }, {
            props: Readonly<LooseRequired<Readonly<ExtractPropTypes<{
                p1: {
                    type: PropType<Position>;
                    required: true;
                };
                p2: {
                    type: PropType<Position>;
                    required: true;
                };
                config: {
                    type: PropType<StrokeStyle>;
                    required: true;
                };
            }>> & {
                [x: string & `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            scale: Ref<number>;
            strokeWidth: ComputedRef<number>;
            strokeDasharray: ComputedRef<string | number | undefined>;
            animationSpeed: ComputedRef<string | undefined>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            p1: {
                type: PropType<Position>;
                required: true;
            };
            p2: {
                type: PropType<Position>;
                required: true;
            };
            config: {
                type: PropType<StrokeStyle>;
                required: true;
            };
        }>>, {}>;
        VShape: DefineComponent<{
            baseX: {
                type: NumberConstructor;
                default: number;
            };
            baseY: {
                type: NumberConstructor;
                default: number;
            };
            config: {
                type: PropType<AnyShapeStyle>;
                required: true;
            };
        }, {
            props: Readonly<LooseRequired<Readonly<ExtractPropTypes<{
                baseX: {
                    type: NumberConstructor;
                    default: number;
                };
                baseY: {
                    type: NumberConstructor;
                    default: number;
                };
                config: {
                    type: PropType<AnyShapeStyle>;
                    required: true;
                };
            }>> & {
                [x: string & `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            scale: Ref<number>;
            x: Ref<number>;
            y: Ref<number>;
            strokeWidth: Ref<number>;
            strokeColor: Ref<string>;
            strokeDasharray: Ref<string | number | undefined>;
            radius: Ref<number>;
            width: Ref<number>;
            height: Ref<number>;
            borderRadius: Ref<number>;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            baseX: {
                type: NumberConstructor;
                default: number;
            };
            baseY: {
                type: NumberConstructor;
                default: number;
            };
            config: {
                type: PropType<AnyShapeStyle>;
                required: true;
            };
        }>>, {
            baseX: number;
            baseY: number;
        }>;
        VText: DefineComponent<{
            text: {
                type: StringConstructor;
                required: true;
            };
            x: {
                type: NumberConstructor;
                required: true;
            };
            y: {
                type: NumberConstructor;
                required: true;
            };
            dominantBaseline: {
                type: StringConstructor;
                required: false;
                default: string;
            };
            config: {
                type: PropType<LabelStyle>;
                required: true;
            };
        }, {
            updateBackgroundPosition: (element: SVGTextElement, pos: {
                x: number;
                y: number;
                width: number;
                height: number;
            }, transform: Ref<string | undefined>) => void;
            enableMutationObserver: (element: SVGTextElement, pos: {
                x: number;
                y: number;
                width: number;
                height: number;
            }, transform: Ref<string | undefined>) => MutationObserver;
            props: Readonly<LooseRequired<Readonly<ExtractPropTypes<{
                text: {
                    type: StringConstructor;
                    required: true;
                };
                x: {
                    type: NumberConstructor;
                    required: true;
                };
                y: {
                    type: NumberConstructor;
                    required: true;
                };
                dominantBaseline: {
                    type: StringConstructor;
                    required: false;
                    default: string;
                };
                config: {
                    type: PropType<LabelStyle>;
                    required: true;
                };
            }>> & {
                [x: string & `on${string}`]: ((...args: any[]) => any) | ((...args: unknown[]) => any) | undefined;
            }>>;
            attrs: {
                [x: string]: unknown;
            };
            scale: Ref<number>;
            texts: ComputedRef<string[]>;
            fontSize: ComputedRef<number>;
            lineHeight: ComputedRef<number>;
            topDeltaY: ComputedRef<number>;
            element: Ref<SVGTextElement | undefined>;
            transform: Ref<string>;
            pos: {
                x: number;
                y: number;
                width: number;
                height: number;
            };
            backgroundRectPos: ComputedRef<{
                x: number;
                y: number;
                width: number;
                height: number;
            }>;
            observer: MutationObserver | undefined;
            updateObserver: () => void;
        }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
            text: {
                type: StringConstructor;
                required: true;
            };
            x: {
                type: NumberConstructor;
                required: true;
            };
            y: {
                type: NumberConstructor;
                required: true;
            };
            dominantBaseline: {
                type: StringConstructor;
                required: false;
                default: string;
            };
            config: {
                type: PropType<LabelStyle>;
                required: true;
            };
        }>>, {
            dominantBaseline: string;
        }>;
    }, unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{
        edges: {
            type: PropType<Edges>;
            required: true;
        };
        layouts: {
            type: PropType<NodePositions>;
            required: true;
        };
    }>>, {}>;
}, {}, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, EmitsOptions, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<ExtractPropTypes<{}>>, {}>;
export default _sfc_main;
